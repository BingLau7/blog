<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在经历过 AbstractAutowireCapableBeanFactory#createBean 中的 resolveBeforeInstantiation 方法后，程序有两个选择，如果创建了代理或者说重写了 InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation 方法并在方法 postProcessBefore">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 源码解析—创建 bean">
<meta property="og:url" content="http://example.com/2017/11/20/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E5%88%9B%E5%BB%BA-bean/index.html">
<meta property="og:site_name" content="村里最好的博客">
<meta property="og:description" content="在经历过 AbstractAutowireCapableBeanFactory#createBean 中的 resolveBeforeInstantiation 方法后，程序有两个选择，如果创建了代理或者说重写了 InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation 方法并在方法 postProcessBefore">
<meta property="og:locale">
<meta property="article:published_time" content="2017-11-20T09:00:18.000Z">
<meta property="article:modified_time" content="2023-12-23T04:03:46.756Z">
<meta property="article:author" content="刘冰鉴">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2017/11/20/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E5%88%9B%E5%BB%BA-bean/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/2017/11/20/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E5%88%9B%E5%BB%BA-bean/","path":"2017/11/20/Spring-源码解析—创建-bean/","title":"Spring 源码解析—创建 bean"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring 源码解析—创建 bean | 村里最好的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">村里最好的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-bean-%E7%9A%84%E5%AE%9E%E4%BE%8B-createBeanInstance"><span class="nav-number">1.</span> <span class="nav-text">创建 bean 的实例 (createBeanInstance)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#autowireConstructor"><span class="nav-number">1.1.</span> <span class="nav-text">autowireConstructor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">构造函数参数的确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%A1%AE%E8%AE%A4"><span class="nav-number">1.1.2.</span> <span class="nav-text">构造函数的确认</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">根据确定的构造函数转换对应的参数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-number">1.1.4.</span> <span class="nav-text">构造参数不确定性的验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%BE%97%E5%88%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96Bean"><span class="nav-number">1.1.5.</span> <span class="nav-text">根据实例化策略以及得到的构造函数及构造函数参数实例化Bean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instantiateBean-%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">instantiateBean 不带参数的构造函数实例化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.</span> <span class="nav-text">实例化策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%88%9B%E5%BB%BA-bean-%E7%9A%84-ObjectFactory"><span class="nav-number">2.</span> <span class="nav-text">记录创建 bean 的 ObjectFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="nav-number">3.</span> <span class="nav-text">属性注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#autowireByName"><span class="nav-number">3.1.</span> <span class="nav-text">autowireByName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autowireByType"><span class="nav-number">3.2.</span> <span class="nav-text">autowireByType</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DefaultListableBeanFactory-resolveDependency"><span class="nav-number">3.2.1.</span> <span class="nav-text">DefaultListableBeanFactory#resolveDependency</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyPropertyValues"><span class="nav-number">3.3.</span> <span class="nav-text">applyPropertyValues</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-bean"><span class="nav-number">4.</span> <span class="nav-text">初始化 bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB-Aware-%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">激活 Aware 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Aware-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text">Aware 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokeAwareMethods"><span class="nav-number">4.1.2.</span> <span class="nav-text">invokeAwareMethods</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">处理器的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-init-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">激活自定义的 init 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-DisposableBean"><span class="nav-number">5.</span> <span class="nav-text">注册 DisposableBean</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘冰鉴</p>
  <div class="site-description" itemprop="description">Res severa est verum gaudium.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/11/20/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E5%88%9B%E5%BB%BA-bean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring 源码解析—创建 bean | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring 源码解析—创建 bean
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-20 17:00:18" itemprop="dateCreated datePublished" datetime="2017-11-20T17:00:18+08:00">2017-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>在经历过 <code>AbstractAutowireCapableBeanFactory#createBean</code> 中的 <code>resolveBeforeInstantiation</code> 方法后，程序有两个选择，如果创建了代理或者说重写了 <code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation</code> 方法并在方法 <code>postProcessBeforeInstantiation</code> 中改变了 <code>bean</code>，则直接返回就可以了，否则需要进行常规 <code>bean</code> 的创建。而这常规 <code>bean</code> 的创建就是在 <code>doCreateBean</code> 中完成的。</p>
<p><code>AbstractAutowireCapableBeanFactory#doCreateBean</code></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123; <span class="comment">// 1</span></span><br><span class="line">		instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">      	 <span class="comment">// 根据指定 bean 使用对应的策略创建新的实例，如：工厂方法、构造函数自动注入、简单初始化</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">	Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">	mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">              	  <span class="comment">// 应用 MergedBeanDefinitionPostProcessor</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); <span class="comment">// 3</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">  	<span class="comment">// 4</span></span><br><span class="line">  	<span class="comment">// 是否需要提前曝光：单例 &amp; 允许循环依赖 &amp; 当前 bean 正在创建中，检测循环依赖</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">// 为了避免后期循环依赖，可以在 bean 初始化完成前将创建实例的 ObjectFactory 加入工厂</span></span><br><span class="line">		addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">              	<span class="comment">// 对 bean 再一次依赖引用，主要应用 SmartInstantiationAware BeanPostProcessor,</span></span><br><span class="line">              	<span class="comment">// 其中我们熟知的 AOP 就是在这里将 advice 动态织入 bean 中，若没有直接返回 bean，不做任何处理</span></span><br><span class="line">				<span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性，则会递归初始依赖 bean</span></span><br><span class="line">       <span class="comment">// 5</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 调用初始化方法，比如 init-method</span></span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      	<span class="comment">// earlySingletonReference 只有在检测到有循环依赖的情况下才会不为空</span></span><br><span class="line">      	<span class="comment">// 6</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 如果 esposedObject 没有在初始化方法中被改变，就是没有被增强</span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                  	  <span class="comment">// 检测依赖</span></span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">              	<span class="comment">// 因为 bean 创建后其所依赖的 bean 一定是已经创建的，</span></span><br><span class="line">              	<span class="comment">// actualDependentBeans 不为空则表示当前 bean 创建后其依赖的 bean 却没有</span></span><br><span class="line">              	<span class="comment">// 全部创建完，也就是说存在循环依赖</span></span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 根据 scopes 注册 bean</span></span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd); <span class="comment">// 7</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> exposedObject; <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果是单例则需要首先清除缓存</p>
</li>
<li><p>实例化 bean，将 <code>BeanDefinition</code> 转换为 <code>BeanWrapper</code></p>
<p>转换是一个复杂的过程，但是我们可以尝试概括大致的功能：</p>
<ul>
<li>如果存在工厂方法则使用工厂方法进行初始化</li>
<li>一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化</li>
<li>如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行 bean 的实例化</li>
</ul>
</li>
<li><p>MergedBeanDefinitionPostProcessor的应用</p>
<p>bean合并后的处理，Autowired注解正是通过此方法实现诸如类型的预解析。</p>
</li>
<li><p>依赖处理</p>
<p>在Spring中会有循环依赖的情况，例如，当A中含有B的属性，而B中又含有A的属性时就会构成一个循环依赖，此时如果A和B都是单例，那么在Spring中的处理方式就是当创建B的时候，涉及自动注入A的步骤时，并不是直接去再次创建A，而是<strong>通过放入缓存中的ObjectFactory来创建实例</strong>，这样就解决了循环依赖的问题。</p>
</li>
<li><p>属性填充。将所有属性填充至bean的实例中</p>
</li>
<li><p>循环依赖检查</p>
<p>Sping 中解决循环依赖只对单例有效，而对于 prototype 的 bean，Spring 没有好的解决办法，唯一要做的就是抛出异常。在这个步骤里面会检测已经加载的 bean 是否已经出现了依赖循环，并判断是否需要抛出异常。</p>
</li>
<li><p>注册DisposableBean</p>
<p>如果配置了destroy-method，这里需要注册以便于在销毁时候调用。</p>
</li>
<li><p>完成创建并返回</p>
</li>
</ol>
<h2 id="创建-bean-的实例-createBeanInstance"><a href="#创建-bean-的实例-createBeanInstance" class="headerlink" title="创建 bean 的实例 (createBeanInstance)"></a>创建 bean 的实例 (createBeanInstance)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance for the specified bean, using an appropriate instantiation strategy:</span></span><br><span class="line"><span class="comment"> * factory method, constructor autowiring, or simple instantiation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">  	<span class="comment">// 解析 class</span></span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">				<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果工厂方法不为空则使用工厂方法初始化策略</span></span><br><span class="line">	<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>)  &#123; <span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	<span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">          	<span class="comment">// 一个类有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">				resolved = <span class="literal">true</span>;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">// 如果已经解析过则使用解析好的构造函数方法不需要再次锁定</span></span><br><span class="line">	<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">		<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">          	<span class="comment">// 构造函数自动注入</span></span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 使用默认构造函数构造</span></span><br><span class="line">			<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Need to determine the constructor...</span></span><br><span class="line">  	<span class="comment">// 需要根据参数解析构造函数</span></span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (ctors != <span class="literal">null</span> ||</span><br><span class="line">			mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      	 <span class="comment">// 构造函数自动注入</span></span><br><span class="line">		<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">  	<span class="comment">// 使用默认构造函数构造</span></span><br><span class="line">	<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果在<code>RootBeanDefinition</code>中存在<code>factoryMethodName</code>属性，或者说在配置文件中配置了<code>factory-method</code>，那么 Spring 会尝试使用<code>instantiateUsingFactoryMethod(beanName, mbd, args)</code>方法根据<code>RootBeanDefinition</code>中的配置生成bean的实例。</li>
<li>解析构造函数并进行构造函数的实例化。因为一个 bean 对应的类中可能会有多个构造函数，而每个构造函数的参数不同，Spring 在根据参数及类型去判断最终会使用哪个构造函数进行实例化。但是，<strong>判断的过程是个比较消耗性能的步骤，所以采用缓存机制</strong>，如果已经解析过则不需要重复解析而是直接从<code>RootBeanDefinition</code>中的属性<code>resolvedConstructorOrFactoryMethod</code>缓存的值去取，否则需要再次解析，并将解析的结果添加至 <code>RootBeanDefinition</code> 中的属性<code>resolvedConstructorOrFactoryMethod</code>中。</li>
</ol>
<h3 id="autowireConstructor"><a href="#autowireConstructor" class="headerlink" title="autowireConstructor"></a><code>autowireConstructor</code></h3><p>对于实例的创建Spring中分成了两种情况，一种是通用的实例化，另一种是带有参数的实例化。带有参数的实例化过程相当复杂，因为存在着不确定性，所以在判断对应参数上做了大量工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;autowire constructor&quot; (with constructor arguments by type) behavior.</span></span><br><span class="line"><span class="comment"> * Also applied if explicit constructor argument values are specified,</span></span><br><span class="line"><span class="comment"> * matching all remaining arguments with beans from the bean factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This corresponds to constructor injection: In this mode, a Spring</span></span><br><span class="line"><span class="comment"> * bean factory is able to host components that expect constructor-based</span></span><br><span class="line"><span class="comment"> * dependency resolution.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctors the chosen candidate constructors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> explicitArgs argument values passed in programmatically via the getBean method,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if none (-&gt; use constructor argument values from bean definition)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"> <span class="keyword">protected</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(</span></span><br><span class="line"><span class="params">		String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt;[] ctors, Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorResolver</span>(<span class="built_in">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边的代码量太大了，不太适合贴出来解析，各位最好还是去 idea 里面进行查看，书中作者也觉得这段不符合 Spring 那种『将复杂的逻辑分解，分成N个小函数的嵌套，每一层都是对下一层逻辑的总结及概要，这样使得每一层的逻辑会变得简单容易理解』的规律。我这里就说明一下整体流程，每段流程贴出对应的代码。</p>
<h4 id="构造函数参数的确定"><a href="#构造函数参数的确定" class="headerlink" title="构造函数参数的确定"></a>构造函数参数的确定</h4><ul>
<li><p>根据explicitArgs参数判断</p>
<p>如果传入的参数<code>explicitArgs</code>不为空，那边可以直接确定参数，因为 <code>explicitArgs</code> 参数是在调用 Bean 的时候用户指定的，在<code>BeanFactory</code>类中存在这样的方法：<br><code>Object getBean(String name, Object... args) throws BeansException;</code><br>在获取 bean 的时候，用户不但可以指定 bean 的名称还可以指定 bean 所对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里是需要给定完全匹配的参数的，所以，便可以判断，如果传入参数<code>explicitArgs</code>不为空，则可以确定构造函数参数就是它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// explicitArgs 通过 getBean 方法传入</span></span><br><span class="line"><span class="comment">// 如果 getBean 方法调用的时候指定方法参数那么直接使用</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">	argsToUse = explicitArgs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存中获取</p>
<p>构造函数参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在缓存中缓存的可能是参数的最终类型也可能是参数的初始类型，例如：构造函数参数要求的是 int 类型，但是原始的参数值可能是String类型的“1”，那么即使在缓存中得到了参数，也需要经过类型转换器的过滤以确保参数类型与对应的构造函数参数类型完全对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     	 <span class="comment">// 如果在 getBean 方法时候没有指定则尝试从配置文件中解析</span></span><br><span class="line">	Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line">     	 <span class="comment">// 尝试从缓存中获取</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">		constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">		<span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">			<span class="comment">// Found a cached constructor...</span></span><br><span class="line">             	  <span class="comment">// 从缓存中取</span></span><br><span class="line">			argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">			<span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                 	  <span class="comment">// 配置的构造函数参数 </span></span><br><span class="line">				argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">     	 <span class="comment">// 如果缓存中存在</span></span><br><span class="line">	<span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line">         	 <span class="comment">// 解析参数类型，如给定方法的构造函数 A(int, int) 则通过此方法后就会把配置汇中的 (&quot;1&quot;, &quot;1&quot;) 转换为 (1, 1)</span></span><br><span class="line">         	 <span class="comment">// 缓存中的值可能是原始值也可能是最终值</span></span><br><span class="line">		argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件获取</p>
<p>如果不能根据传入的参数 <code>explicitArgs</code> 确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析了。<br>分析从获取配置文件中配置的构造函数信息开始，经过之前的分析，我们知道，Spring中配置文件中的信息经过转换都会通过 <code>BeanDefinition</code> 实例承载，也就是参数<code>mbd</code>中包含，那么可以通过调用 <code>mbd.getConstructorArgumentValues()</code>来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息了，获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型 String 类型，或者是一个对其他 bean 的引用，而这一处理委托给<code>resolveConstructorArguments</code>方法，并返回能解析到的参数的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need to resolve the constructor.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autowiring</span> <span class="operator">=</span> (chosenCtors != <span class="literal">null</span> ||</span><br><span class="line">		mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"><span class="type">ConstructorArgumentValues</span> <span class="variable">resolvedValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minNrOfArgs;</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">	minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     	 <span class="comment">// 提取配置文件中的配置的构造函数参数</span></span><br><span class="line">	<span class="type">ConstructorArgumentValues</span> <span class="variable">cargs</span> <span class="operator">=</span> mbd.getConstructorArgumentValues();</span><br><span class="line">     	 <span class="comment">// 用于承载解析后的构造函数参数的值</span></span><br><span class="line">	resolvedValues = <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line">     	 <span class="comment">// 能解析到的参数个数</span></span><br><span class="line">	minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构造函数的确认"><a href="#构造函数的确认" class="headerlink" title="构造函数的确认"></a>构造函数的确认</h4><p>经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数数量降序、非public构造函数参数数量降序。这样可以在遍历的情况下迅速判断排在后面的构造函数参数个数是否符合条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line"><span class="keyword">if</span> (candidates == <span class="literal">null</span>) &#123;</span><br><span class="line">	Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">				beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">				<span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">				<span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序给定的构造函数，public 构造函数优先参数数量排序、非 public 构造函数参数数量降序</span></span><br><span class="line">AutowireUtils.sortConstructors(candidates);</span><br></pre></td></tr></table></figure>

<p>由于在配置文件中并不是唯一限制使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如<code>&lt;constructor-arg name=&quot;aa&quot;&gt;</code>，那么这种情况就需要首先确定构造函数中的参数名称。</p>
<p>获取参数名称可以有两种方式</p>
<ol>
<li><p>通过注解的方式直接获取，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Spring中提供的工具类 <code>ParameterNameDiscoverer</code> 来获取。构造函数、参数名称、参数类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (paramNames == <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="type">ParameterNameDiscoverer</span> <span class="variable">pnd</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">	<span class="keyword">if</span> (pnd != <span class="literal">null</span>) &#123;</span><br><span class="line">		paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="根据确定的构造函数转换对应的参数类型"><a href="#根据确定的构造函数转换对应的参数类型" class="headerlink" title="根据确定的构造函数转换对应的参数类型"></a>根据确定的构造函数转换对应的参数类型</h4><p>主要是使用Spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">								getUserDeclaredConstructor(candidate), autowiring);</span><br></pre></td></tr></table></figure>

<h4 id="构造参数不确定性的验证"><a href="#构造参数不确定性的验证" class="headerlink" title="构造参数不确定性的验证"></a>构造参数不确定性的验证</h4><p>当然，有时候即使构造函数、参数名称、参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子关系，所以Spring在最后又做了一次验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 探测是否有不确定性的构造函数存在，例如不同构造函数的参数为父子关系</span></span><br><span class="line"><span class="type">int</span> <span class="variable">typeDiffWeight</span> <span class="operator">=</span> (mbd.isLenientConstructorResolution() ?</span><br><span class="line">		argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line"><span class="comment">// 如果它代表着当前最接近的匹配则选择作为构造函数</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">	constructorToUse = candidate;</span><br><span class="line">	argsHolderToUse = argsHolder;</span><br><span class="line">	argsToUse = argsHolder.arguments;</span><br><span class="line">	minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">	ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">	<span class="keyword">if</span> (ambiguousConstructors == <span class="literal">null</span>) &#123;</span><br><span class="line">		ambiguousConstructors = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Constructor&lt;?&gt;&gt;();</span><br><span class="line">		ambiguousConstructors.add(constructorToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	ambiguousConstructors.add(candidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据实例化策略以及得到的构造函数及构造函数参数实例化Bean"><a href="#根据实例化策略以及得到的构造函数及构造函数参数实例化Bean" class="headerlink" title="根据实例化策略以及得到的构造函数及构造函数参数实例化Bean"></a>根据实例化策略以及得到的构造函数及构造函数参数实例化Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="keyword">final</span> Constructor&lt;?&gt; ctorToUse = constructorToUse;</span><br><span class="line">	<span class="keyword">final</span> Object[] argumentsToUse = argsToUse;</span><br><span class="line">	beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">					mbd, beanName, beanFactory, ctorToUse, argumentsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, beanFactory.getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	beanInstance = <span class="built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">			mbd, beanName, <span class="built_in">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面章节进行描述。</p>
<h3 id="instantiateBean-不带参数的构造函数实例化过程"><a href="#instantiateBean-不带参数的构造函数实例化过程" class="headerlink" title="instantiateBean 不带参数的构造函数实例化过程"></a><code>instantiateBean</code> 不带参数的构造函数实例化过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">	<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">		<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the given bean using its default constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object beanInstance;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">			beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例化策略"><a href="#实例化策略" class="headerlink" title="实例化策略"></a>实例化策略</h3><p>其实，经过前面的分析，我们已经得到了足以实例化的所有相关信息，完全可以使用最简单的反射方法直接反射来构造实例对象，但是Spring却并没有这么做。</p>
<p><code>SimpleInstantiationStrategy#instantiate</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> &#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line">  	 <span class="comment">// 如果有需要覆盖或者动态替换的方法则当然需要使用 cglib 进行动态代理，因为可以在</span></span><br><span class="line">  	 <span class="comment">// 创建代理的同时将方法将动态方法织入类中，但是如果没有需要动态改变的方法，为了</span></span><br><span class="line">  	 <span class="comment">// 方便直接反射就可以了</span></span><br><span class="line">	<span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">		Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">		<span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">			constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">			<span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">				<span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">						constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">								<span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="literal">null</span>);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						constructorToUse =	clazz.getDeclaredConstructor((Class[]) <span class="literal">null</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">		<span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CglibSubclassingInstantiationStrategy#instantiate</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An inner class created for historical reasons to avoid external CGLIB dependency</span></span><br><span class="line"><span class="comment"> * in Spring versions earlier than 3.2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibSubclassCreator</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] CALLBACK_TYPES = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]</span><br><span class="line">			&#123;NoOp.class, LookupOverrideMethodInterceptor.class, ReplaceOverrideMethodInterceptor.class&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RootBeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BeanFactory owner;</span><br><span class="line"></span><br><span class="line">	CglibSubclassCreator(RootBeanDefinition beanDefinition, BeanFactory owner) &#123;</span><br><span class="line">		<span class="built_in">this</span>.beanDefinition = beanDefinition;</span><br><span class="line">		<span class="built_in">this</span>.owner = owner;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new instance of a dynamically generated subclass implementing the</span></span><br><span class="line"><span class="comment">	 * required lookups.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ctor constructor to use. If this is &#123;<span class="doctag">@code</span> null&#125;, use the</span></span><br><span class="line"><span class="comment">	 * no-arg constructor (no parameterization, or Setter Injection)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use for the constructor.</span></span><br><span class="line"><span class="comment">	 * Ignored if the &#123;<span class="doctag">@code</span> ctor&#125; parameter is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> new instance of the dynamically generated subclass</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(Constructor&lt;?&gt; ctor, Object... args)</span> &#123;</span><br><span class="line">		Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="built_in">this</span>.beanDefinition);</span><br><span class="line">		Object instance;</span><br><span class="line">		<span class="keyword">if</span> (ctor == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">				instance = enhancedSubclassConstructor.newInstance(args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(<span class="built_in">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line">						<span class="string">&quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot;</span> + subclass.getName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line">		<span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">		<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> (Factory) instance;</span><br><span class="line">		factory.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[] &#123;NoOp.INSTANCE,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">LookupOverrideMethodInterceptor</span>(<span class="built_in">this</span>.beanDefinition, <span class="built_in">this</span>.owner),</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">ReplaceOverrideMethodInterceptor</span>(<span class="built_in">this</span>.beanDefinition, <span class="built_in">this</span>.owner)&#125;);</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an enhanced subclass of the bean class for the provided bean</span></span><br><span class="line"><span class="comment">	 * definition, using CGLIB.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) &#123;</span><br><span class="line">		<span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">		enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.owner <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">			<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ((ConfigurableBeanFactory) <span class="built_in">this</span>.owner).getBeanClassLoader();</span><br><span class="line">			enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(cl));</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">MethodOverrideCallbackFilter</span>(beanDefinition));</span><br><span class="line">		enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br><span class="line">		<span class="keyword">return</span> enhancer.createClass();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="记录创建-bean-的-ObjectFactory"><a href="#记录创建-bean-的-ObjectFactory" class="headerlink" title="记录创建 bean 的 ObjectFactory"></a>记录创建 bean 的 ObjectFactory</h2><p>在 <code>doCreate</code> 函数中有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 是否需要提前曝光：单例 &amp; 允许循环依赖 &amp; 当前 bean 正在创建中，检测循环依赖</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">		isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">				<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">// 为了避免后期循环依赖，可以在 bean 初始化完成前将创建实例的 ObjectFactory 加入工厂</span></span><br><span class="line">	addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">          	<span class="comment">// 对 bean 再一次依赖引用，主要应用 SmartInstantiationAware BeanPostProcessor,</span></span><br><span class="line">          	<span class="comment">// 其中我们熟知的 AOP 就是在这里将 advice 动态织入 bean 中，若没有直接返回 bean，不做任何处理</span></span><br><span class="line">			<span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>mbd.isSingleton</code>: 是否是单例</p>
</li>
<li><p><code>this.allowCircularReferences</code>: 是否允许循环依赖，很抱歉，并没有找到在配置文件中如何配置，但是在 AbstractRefreshableApplicationContext 中提供了设置函数，可以通过硬编码的方式进行设置或者可以通过自定义命名空间进行配置，其中硬编码的方式代码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span> (<span class="string">&quot;aspectTest.xml&quot;</span>);</span><br><span class="line">bf.setAllowBeanDefinitionOverriding(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>isSingletonCurrentlyInCreation(beanName)</code>: 该bean是否在创建中。在Spring中，会有个专门的属性默认为<code>DefaultSingletonBeanRegistry</code>的<code>singletonsCurrentlyInCreation</code>来记录bean的加载状态，在bean开始创建前会将beanName记录在属性中，在bean创建结束后会将 beanName 从属性中移除。</p>
<p>记录状态的点，不同 scope 的位置不一样，以  <code>singleton</code> 为例，在singleton下记录属性的函数是在<code>DefaultSingletonBeanRegistry</code>类的 <code>public Object getSingleton(String beanName, ObjectFactory singletonFacotry)</code> 函数的 <code>beforeSingletonCreation(beanName)</code> 和 <code>afterSingletonCreation(beanName)</code> 中，在这两段函数中分别是 <code>this.singletonsCurrentlyInCreation.add(beanName)</code> 与 <code>this.singletonsCurrentlyInCreation.remove(beanName)</code> 来进行状态的记录与移除。</p>
</li>
</ul>
<h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Populate the bean instance in the given BeanWrapper with the property values</span></span><br><span class="line"><span class="comment"> * from the bean definition.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw BeanWrapper with bean instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> &#123;</span><br><span class="line">	<span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">          	 <span class="comment">// 没有可填充的属性</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">	<span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">	<span class="comment">// to support styles of field injection.</span></span><br><span class="line">     <span class="comment">// 给 InstantiationAwareBeanPostprocessors 最优一次机会在属性设置前来改变 bean</span></span><br><span class="line">     <span class="comment">// 如：可以用来支持属性注入的类型</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123; <span class="comment">// 1</span></span><br><span class="line">				<span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">              	  <span class="comment">// 返回值为是否继续填充 bean</span></span><br><span class="line">				<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">					continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果后处理器发出停止填充命令则终止后续的运行</span></span><br><span class="line">	<span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	 <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">			mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">		<span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      	 <span class="comment">// 根据名称自动注入</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">			autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      	 <span class="comment">// 根据类型自动注入</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pvs = newPvs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	 <span class="comment">// 后处理器已经初始化</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">  	 <span class="comment">// 需要依赖检查</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">		PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123; <span class="comment">// 3</span></span><br><span class="line">					<span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                  	  <span class="comment">// 对所有需要依赖检查的属性进行后处理</span></span><br><span class="line">					pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">          	 <span class="comment">// 依赖检查，对应 depends-on 属性， 3.0 已经弃用此属性</span></span><br><span class="line">			checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">  	 <span class="comment">// 将属性应用到 bean 中</span></span><br><span class="line">	applyPropertyValues(beanName, mbd, bw, pvs); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>InstantiationAwareBeanPostProcessor</code>处理器的<code>postProcessAfterInstantiation</code>函数的应用，此函数可以控制程序是否继续进行属性填充。</li>
<li>根据注入类型（byName&#x2F;byType），提取依赖的 bean，并统一存入<code>PropertyValues</code>中。</li>
<li>应用<code>InstantiationAwareBeanPostProcessor</code>处理器的<code>postProcessPropertyValues</code>方法，对属性获取完毕填充前对属性的再次处理，典型应用是 <code>RequiredAnnotationBeanPostProcessor</code> 类中对属性的验证。</li>
<li>将所有<code>PropertyValues</code>中的属性填充至<code>BeanWrapper</code>中。</li>
</ol>
<p>在上面的步骤中有几个地方是我们比较感兴趣的，它们分别是依赖注入（ <code>autowireByName</code>&#x2F;<code>autowireByType</code>）以及属性填充，那么，接下来进一步分析这几个功能的实现细节。</p>
<h3 id="autowireByName"><a href="#autowireByName" class="headerlink" title="autowireByName"></a><code>autowireByName</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByName</span><span class="params">(</span></span><br><span class="line"><span class="params">		String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 寻找 bw 中需要依赖注入的属性</span></span><br><span class="line">	String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">	<span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">          	 <span class="comment">// 递归初始化相关的 bean </span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(propertyName);</span><br><span class="line">			pvs.add(propertyName, bean);</span><br><span class="line">             <span class="comment">// 注册依赖</span></span><br><span class="line">			registerDependentBean(propertyName, beanName);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autowireByType"><a href="#autowireByType" class="headerlink" title="autowireByType"></a><code>autowireByType</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByType</span><span class="params">(</span></span><br><span class="line"><span class="params">		String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">	<span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">		converter = bw;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(<span class="number">4</span>);</span><br><span class="line">     <span class="comment">// 寻找 bw 中需要依赖注入的属性</span></span><br><span class="line">	String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">	<span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName);</span><br><span class="line">			<span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">			<span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">			<span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line">              	  <span class="comment">// 探测指定属性的 set 方法</span></span><br><span class="line">				<span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">				<span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">				<span class="type">boolean</span> <span class="variable">eager</span> <span class="operator">=</span> !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());</span><br><span class="line">				<span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireByTypeDependencyDescriptor</span>(methodParam, eager);</span><br><span class="line">				<span class="type">Object</span> <span class="variable">autowiredArgument</span> <span class="operator">=</span> resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">              	  <span class="comment">// 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 </span></span><br><span class="line">              	  <span class="comment">// autowireBeanNames 中，当属性存在多个封装 bean 时，如:</span></span><br><span class="line">                  <span class="comment">// @Autowired private List&lt;A&gt; aList; 将会找到所有匹配 A 类型</span></span><br><span class="line">                  <span class="comment">// 的 bean 并将其注入</span></span><br><span class="line">				<span class="keyword">if</span> (autowiredArgument != <span class="literal">null</span>) &#123;</span><br><span class="line">					pvs.add(propertyName, autowiredArgument);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">                  	  <span class="comment">// 注册依赖</span></span><br><span class="line">					registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +</span><br><span class="line">								propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				autowiredBeanNames.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现根据名称自动匹配的第一步就是寻找 <code>bw</code> 中需要依赖注入的属性，同样对于根据类型自动匹配的实现来讲第一步也是寻找<code>bw</code>中需要依赖注入的属性，然后遍历这些属性并寻找类型匹配的 bean，其中最复杂的就是寻找类型匹配的 bean。</p>
<h4 id="DefaultListableBeanFactory-resolveDependency"><a href="#DefaultListableBeanFactory-resolveDependency" class="headerlink" title="DefaultListableBeanFactory#resolveDependency"></a><code>DefaultListableBeanFactory#resolveDependency</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String requestingBeanName,</span></span><br><span class="line"><span class="params">		Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">	<span class="keyword">if</span> (javaUtilOptionalClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptionalDependencyFactory</span>().createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">			ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">         <span class="comment">// ObjectFactory 类注入的特殊处理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyObjectProvider</span>(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">         <span class="comment">// javaxInjectProviderClass 类注入的特殊处理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jsr330ProviderFactory</span>().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">				descriptor, requestingBeanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 通用逻辑处理</span></span><br><span class="line">			result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName,</span></span><br><span class="line"><span class="params">		Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">InjectionPoint</span> <span class="variable">previousInjectionPoint</span> <span class="operator">=</span> ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">shortcut</span> <span class="operator">=</span> descriptor.resolveShortcut(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (shortcut != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> shortcut;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">         <span class="comment">// 用于支持 Spring 中的注解 @Value</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> resolveEmbeddedValue((String) value);</span><br><span class="line">				<span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (beanName != <span class="literal">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="literal">null</span>);</span><br><span class="line">				value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> (typeConverter != <span class="literal">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">			<span class="keyword">return</span> (descriptor.getField() != <span class="literal">null</span> ?</span><br><span class="line">					converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">					converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">multipleBeans</span> <span class="operator">=</span> resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">		<span class="keyword">if</span> (multipleBeans != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> multipleBeans;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 根据属性类型找到 beanFactory 中所有类型的匹配 bean，</span></span><br><span class="line">         <span class="comment">// 返回值的构成为： key: 匹配的 beanName, value: beanName 对应的实例化后的 bean(通过 getBean(beanName) 返回)</span></span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">          	  <span class="comment">// 如果 autowire 的 require 属性为 true 而找到的匹配项却为空则只能抛出异常</span></span><br><span class="line">			<span class="keyword">if</span> (descriptor.isRequired()) &#123;</span><br><span class="line">				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String autowiredBeanName;</span><br><span class="line">		Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">			<span class="keyword">if</span> (autowiredBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (descriptor.isRequired() || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">					<span class="keyword">return</span> descriptor.resolveNotUnique(type, matchingBeans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">					<span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">					<span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We have exactly one match.</span></span><br><span class="line">			Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">			autowiredBeanName = entry.getKey();</span><br><span class="line">			instanceCandidate = entry.getValue();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="literal">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (instanceCandidate <span class="keyword">instanceof</span> Class ?</span><br><span class="line">				descriptor.resolveCandidate(autowiredBeanName, type, <span class="built_in">this</span>) : instanceCandidate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyPropertyValues"><a href="#applyPropertyValues" class="headerlink" title="applyPropertyValues"></a><code>applyPropertyValues</code></h3><p>程序运行到这里，已经完成了对所有注入属性的获取，但是获取的属性是以<code>PropertyValues</code>形式存在的，还并没有应用到已经实例化的bean中，这一工作是在<code>applyPropertyValues</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply the given property values, resolving any runtime references</span></span><br><span class="line"><span class="comment"> * to other beans in this bean factory. Must use deep copy, so we</span></span><br><span class="line"><span class="comment"> * don&#x27;t permanently modify this property.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the bean name passed for better exception information</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw the BeanWrapper wrapping the target object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pvs the new property values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (pvs == <span class="literal">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">			((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">		mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">         <span class="comment">// 如果 mpvs 中的值已经被转换为对应的类型那么可以直接设置到 beanWapper 中</span></span><br><span class="line">		<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">			<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				bw.setPropertyValues(mpvs);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		original = mpvs.getPropertyValueList();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果 pvs 并不是使用 MutablePropertyValues 封装的类型，那么直接使用原始的属性获取方法</span></span><br><span class="line">		original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">	<span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">		converter = bw;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">// 获取对应的解析器</span></span><br><span class="line">	<span class="type">BeanDefinitionValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValueResolver</span>(<span class="built_in">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">	List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PropertyValue&gt;(original.size());</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">resolveNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// 遍历属性，将属性转换为对应类的对应属性的类型</span></span><br><span class="line">	<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">			deepCopy.add(pv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> resolvedValue;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">convertible</span> <span class="operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">					!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">			<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">				convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">			<span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					pv.setConvertedValue(convertedValue);</span><br><span class="line">				&#125;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">					!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">					!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">				pv.setConvertedValue(convertedValue);</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">				deepCopy.add(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv, convertedValue));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mpvs != <span class="literal">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">		mpvs.setConverted();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化-bean"><a href="#初始化-bean" class="headerlink" title="初始化 bean"></a>初始化 bean</h2><p>大家应该记得在 bean 配置时 bean 中有一个<code>init-method</code>的属性，这个属性的作用是在 bean 实例化前调用<code>init-method</code>指定的方法来根据用户业务进行相应的实例化。我们现在就已经进入这个方法了，首先看一下这个方法的执行位置，Spring中程序已经执行过bean的实例化，并且进行了属性的填充，而就在这时将会调用用户设定的初始化方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, getAccessControlContext());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      	 <span class="comment">// 应用后处理器</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 激活用户自定义的 init 方法</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">				beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">         <span class="comment">// 后处理器应用</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="激活-Aware-方法"><a href="#激活-Aware-方法" class="headerlink" title="激活 Aware 方法"></a>激活 Aware 方法</h3><p>Spring 中提供一些 Aware 相关接口，比如 <code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>ResourceLoaderAware</code>、<code>ServletContextAware</code> 等，实现这些 Aware 接口的 bean 在被初始之后，可以取得一些相对应的资源，例如实现<code>BeanFactoryAware</code> 的 bean 在初始后， Spring 容器将会注入 <code>BeanFactory</code> 的实例，而实现<code>ApplicationContextAware</code>的bean，在bean被初始后，将会被注入<code>ApplicationContext</code>的实例等。</p>
<h4 id="Aware-的使用"><a href="#Aware-的使用" class="headerlink" title="Aware 的使用"></a>Aware 的使用</h4><ol>
<li><p>定义 bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 <code>BeanFactoryAware</code> 类型的 bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAware</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 bean 的时候 Spring 会自动注入 BeanFactory</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAware</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 hello 这个 bean id 从 beanFactory 获取实例</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) beanFactory.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        hello.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;testAware.xml&quot;</span>);</span><br><span class="line">    <span class="type">TestAware</span> <span class="variable">testAware</span> <span class="operator">=</span> (TestAware) ctx.getBean(<span class="string">&quot;testAware&quot;</span>);</span><br><span class="line">    testAware.testAware();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="invokeAwareMethods"><a href="#invokeAwareMethods" class="headerlink" title="invokeAwareMethods"></a><code>invokeAwareMethods</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">			((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">			((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理器的应用"><a href="#处理器的应用" class="headerlink" title="处理器的应用"></a>处理器的应用</h3><p><code>BeanPostProcessor</code>相信大家都不陌生，这是 Spring 中开放式架构中一个必不可少的亮点，给用户充足的权限去更改或者扩展 Spring ，而除了 <code>BeanPostProcessor</code> 外还有很多其他的 <code>PostProcessor</code>，当然大部分都是以此为基础，继承自 <code>BeanPostProcessor</code>。<code>BeanPostProcessor</code> 的使用位置就是这里，在调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 和<code>postProcessAfterInitialization</code>方法，使用户可以根据自己的业务需求进行响应的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="激活自定义的-init-方法"><a href="#激活自定义的-init-方法" class="headerlink" title="激活自定义的 init 方法"></a>激活自定义的 init 方法</h3><p>客户定制的初始化方法除了我们熟知的使用配置<code>init-method</code>外，还有使自定义的 bean 实现<code>InitializingBean</code>接口，并在<code>afterPropertiesSet</code>中实现自己的初始化业务逻辑。</p>
<p><code>init-method</code>与<code>afterPropertiesSet</code>都是在初始化 bean 时执行，执行顺序是<code>afterPropertiesSet</code>先执行，而<code>init-method</code>后执行。</p>
<p>在<code>invokeInitMethods</code>方法中就实现了这两个步骤的初始化方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span><br><span class="line">		<span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// 首先会检查是否是 InitializingBean，如果是的话需要调用 afterPropertiesSet 方法</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">isInitializingBean</span> <span class="operator">=</span> (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">	<span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">						((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				<span class="keyword">throw</span> pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 属性初始化后的处理</span></span><br><span class="line">			((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> mbd.getInitMethodName();</span><br><span class="line">		<span class="keyword">if</span> (initMethodName != <span class="literal">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">				!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">              <span class="comment">// 调用自定义初始化方法</span></span><br><span class="line">			invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册-DisposableBean"><a href="#注册-DisposableBean" class="headerlink" title="注册 DisposableBean"></a>注册 <code>DisposableBean</code></h2><p>Spring 中不但提供了对于初始化方法的扩展入口，同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，除了我们熟知的配置属性<code>destroy-method</code>方法外，用户还可以注册后处理器<code>DestructionAwareBeanPostProcessor</code>来统一处理bean的销毁方法，代码如下(<code>doCreateBean</code>中)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">	<span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> (System.getSecurityManager() != <span class="literal">null</span> ? getAccessControlContext() : <span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">			<span class="comment">// Register a DisposableBean implementation that performs all destruction</span></span><br><span class="line">			<span class="comment">// work for the given bean: DestructionAwareBeanPostProcessors,</span></span><br><span class="line">			<span class="comment">// DisposableBean interface, custom destroy method.</span></span><br><span class="line">              <span class="comment">// 单例模式下注册需要销毁的 bean，此方法中会处理实现 DisposableBean 的 bean，</span></span><br><span class="line">              <span class="comment">// 并且堆所有的 bean 使用 DestructionAwareBeanPostProcessors 处理</span></span><br><span class="line">              <span class="comment">// DisposableBean DestructionAwareBeanPostProcessors</span></span><br><span class="line">			registerDisposableBean(beanName,</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">DisposableBeanAdapter</span>(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// A bean with a custom scope...</span></span><br><span class="line">              <span class="comment">// 自定义 scope 的处理</span></span><br><span class="line">			<span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(mbd.getScope());</span><br><span class="line">			<span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + mbd.getScope() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			scope.registerDestructionCallback(beanName,</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">DisposableBeanAdapter</span>(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/11/17/JVM%E7%B3%BB%E5%88%97%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="prev" title="JVM系列—虚拟机类加载机制">
                  <i class="fa fa-angle-left"></i> JVM系列—虚拟机类加载机制
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/11/23/ElasticSearch%E5%9F%BA%E7%A1%80/" rel="next" title="ElasticSearch基础">
                  ElasticSearch基础 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘冰鉴</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
