<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="紧接 Kafka生产者分析——KafkaProducer  前文介绍过，KafkaProducer 可以有同步和异步两种方式发送消息，其实两者的底层实现相同，都是通过异步方式实现的。主线程调用 KafkaProducer#send() 方法发送消息的时候，先将消息放到 RecordAccumulator 中暂存，然后主线程就可以从 send() 方法中返回了，此时消息并没有真正地发送给 Kaf">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka生产者分析——RecordAccumulator">
<meta property="og:url" content="http://example.com/2017/12/24/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RecordAccumulator/index.html">
<meta property="og:site_name" content="村里最好的博客">
<meta property="og:description" content="紧接 Kafka生产者分析——KafkaProducer  前文介绍过，KafkaProducer 可以有同步和异步两种方式发送消息，其实两者的底层实现相同，都是通过异步方式实现的。主线程调用 KafkaProducer#send() 方法发送消息的时候，先将消息放到 RecordAccumulator 中暂存，然后主线程就可以从 send() 方法中返回了，此时消息并没有真正地发送给 Kaf">
<meta property="og:locale">
<meta property="og:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordAccumulator&RecordBatch&MemoryRecords.jpg?raw=true">
<meta property="og:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_43/Compressor-putXXX.png?raw=true">
<meta property="og:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordBatch.png?raw=true">
<meta property="og:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordBatch-done.jpg?raw=true">
<meta property="article:published_time" content="2017-12-24T11:38:31.000Z">
<meta property="article:modified_time" content="2023-12-23T04:03:46.752Z">
<meta property="article:author" content="刘冰鉴">
<meta property="article:tag" content="Kafka">
<meta property="article:tag" content="分布式与中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordAccumulator&RecordBatch&MemoryRecords.jpg?raw=true">


<link rel="canonical" href="http://example.com/2017/12/24/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RecordAccumulator/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/2017/12/24/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RecordAccumulator/","path":"2017/12/24/Kafka生产者分析——RecordAccumulator/","title":"Kafka生产者分析——RecordAccumulator"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Kafka生产者分析——RecordAccumulator | 村里最好的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">村里最好的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MemoryRecords"><span class="nav-number">1.</span> <span class="nav-text">MemoryRecords</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RecordBatch"><span class="nav-number">2.</span> <span class="nav-text">RecordBatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BufferPool"><span class="nav-number">3.</span> <span class="nav-text">BufferPool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RecordAccumulator"><span class="nav-number">4.</span> <span class="nav-text">RecordAccumulator</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘冰鉴</p>
  <div class="site-description" itemprop="description">Res severa est verum gaudium.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/12/24/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RecordAccumulator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Kafka生产者分析——RecordAccumulator | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kafka生产者分析——RecordAccumulator
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-12-24 19:38:31" itemprop="dateCreated datePublished" datetime="2017-12-24T19:38:31+08:00">2017-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p> 紧接 <a target="_blank" rel="noopener" href="https://binglau7.github.io/2017/12/18/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94KafkaProducer/">Kafka生产者分析——KafkaProducer</a></p>
</blockquote>
<p>前文介绍过，KafkaProducer 可以有同步和异步两种方式发送消息，其实两者的底层实现相同，都是通过异步方式实现的。主线程调用 <code>KafkaProducer#send()</code> 方法发送消息的时候，先将消息放到 <code>RecordAccumulator</code> 中暂存，然后主线程就可以从 <code>send()</code> 方法中返回了，此时消息并没有真正地发送给 Kafka，而是缓存在了 <code>RecordAccumulator</code> 中。之后，业务线程<strong>通过 <code>KafkaProducer#send()</code> 方法不断向 <code>RecordAccumulator</code> 追加消息，当达到一定的条件，会唤醒 <code>Sender</code> 线程发送 <code>RecordAccumulator</code> 中的消息。</strong></p>
<p>下面我们就来介绍 <code>RecordAccumulator</code> 的结构。首先需要注意的是，**<code>RecordAccumulator</code> 至少有一个业务线程和一个 <code>Sender</code> 线程并发操作，所以必须是线程安全的**。</p>
<span id="more"></span>

<p><code>RecordAccumulator</code> 中有一个以 <code>TopicPartition</code> 为 key 的 <code>ConcurrentMap</code> ，每个 value 是 <code>ArrayDeque&lt;RecordBatch&gt;</code> （<code>ArrayDeque</code> 并不是线程安全的集合，后面会详细介绍其加锁处理过程），其中缓存了发往对应 <code>TopicPartition</code> 的消息。每个 <code>RecordBatch</code> 拥有一个 <code>MemoryRecords</code> 对象的引用。<code>MemoryRecords</code> 才是消息最终存放的地方。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordAccumulator&RecordBatch&MemoryRecords.jpg?raw=true" alt="RecordAccumulator&amp;RecordBatch&amp;MemoryRecords"></p>
<h2 id="MemoryRecords"><a href="#MemoryRecords" class="headerlink" title="MemoryRecords"></a><code>MemoryRecords</code></h2><p>我们从最底层的 <code>MemoryRecords</code> 开始分析。<code>MemoryRecords</code> 表示的是多个消息的集合，其中封装了 Java NIO ByteBuffer 用来保存消息数据，<code>Compressor</code> 用于对 <code>ByteBuffer</code> 中的消息进行压缩，以及其他控制字段。其中有四个字段比较重要：</p>
<ul>
<li>buffer：用于保存消息数据的 Java NIO ByteBuffer</li>
<li>writeLimit：记录 buffer 字段最多可以写入多少个字节的数据</li>
<li>compressor：压缩器，对消息数据进行压缩，将压缩后的数据输出到 buffer。</li>
<li>writable：此 <code>MemoryRecords</code> 对象是只读的模式，还是可写模式。在 <code>MemoryRecords</code> 发送前，会将其设置成只读模式。</li>
</ul>
<p>在 Compressor 比较重要的字段和方法，有两个输出流类型的字段：</p>
<ul>
<li><p><code>bufferStream</code></p>
<p>在 buffer 上建立的 <code>ByteBufferOutputStream</code> (Kafka 自己提供的实现)对象，<code>ByteBufferOutputStream</code> 继承了 <code>java.io.OutputStream</code> ，封装了 <code>ByteBuffer</code>，当写入数据超过 <code>ByteBuffer</code> 容量时，<code>ByteBufferOutputStream</code> 会进行自动扩容。</p>
</li>
<li><p><code>appendStream</code></p>
<p><code>DataOutputStream</code> 类型，是对 <code>bufferStream</code> 进行了一层装饰，为其添加了压缩的功能。</p>
</li>
</ul>
<p><code>MemoryRecords</code> 中的 <code>Compressor</code> 的压缩类型是由 <code>compression.type</code> 配置参数指定的，即 <code>KafkaProducer.compressor.type</code> 字段的指。</p>
<p>下面来分析一下创建压缩流的方式，目前 <code>KafkaProducer</code> 支持 <code>GZIP、SNAPPY、LZ4</code> 三种压缩方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">Compressor</span><span class="params">(ByteBuffer buffer, CompressionType type)</span> &#123;</span><br><span class="line">      <span class="comment">/* 从 KafkaProducer 传递过来的压缩类型 */</span></span><br><span class="line">      <span class="built_in">this</span>.type = type;</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// create the stream</span></span><br><span class="line">      bufferStream = <span class="keyword">new</span> <span class="title class_">ByteBufferOutputStream</span>(buffer);</span><br><span class="line">      <span class="comment">/* 下面根据压缩类型创建合适的压缩流 */</span></span><br><span class="line">      appendStream = wrapForOutput(bufferStream, type, COMPRESSION_DEFAULT_BUFFER_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DataOutputStream <span class="title function_">wrapForOutput</span><span class="params">(ByteBufferOutputStream buffer, CompressionType type, <span class="type">int</span> bufferSize)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">switch</span> (type) &#123;  <span class="comment">/* 根据不同的类型选择创建不同压缩流 */</span></span><br><span class="line">              <span class="keyword">case</span> NONE: <span class="comment">/* 不压缩的方式 */</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(buffer);</span><br><span class="line">              <span class="keyword">case</span> GZIP:</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(buffer, bufferSize) <span class="comment">/* 使用 JDK 自带的包 */</span>);</span><br><span class="line">              <span class="keyword">case</span> SNAPPY:</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">/* 使用额外引入的依赖包，为了在不使用 Snappy 压缩方式时，减少依赖包，使用反射的方式动态创建(如果不使用反射则会造成为多个压缩方式的第三方依赖做初始化工作的时间损耗) */</span></span><br><span class="line">                      <span class="type">OutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (OutputStream) snappyOutputStreamSupplier.get().newInstance(buffer, bufferSize);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(stream);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(e);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="keyword">case</span> LZ4:</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="type">OutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (OutputStream) lz4OutputStreamSupplier.get().newInstance(buffer);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(stream);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(e);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown compression type: &quot;</span> + type);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>Compressor</code> 提供了一系列 <code>put*()</code> 方法，向 <code>appendStream</code> 流写入数据，一个典型的装饰器模式的运用，通过 <code>bufferStream</code>  装饰，添加自动扩容的功能；通过 <code>appendStream</code> 装饰后，添加压缩功能。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/Compressor-putXXX.png?raw=true" alt="Compressor装饰器模式"></p>
<p><code>Compressor.estimateBytesWritten()</code> 方法的功能是根据指定压缩方式的压缩率，写入的未压缩数据的字节数（<code>writtenUncompressed</code> 字段记录）、估算因子（COMPRESSION_RATE_ESTIMATION_FACTOR 字段），估计已写入的（压缩后的）字节数，次方法主要用来判断 <code>MemoryRecords</code> 是否写满的逻辑中使用。</p>
<p>下面分析过程暂且认为是使用的非压缩方式（None）。</p>
<p>了解了 <code>Compressor</code> 的实现逻辑后，我们回到 <code>MemoryRecords</code> 继续分析。<code>MemoryRecords</code> 的构造方法是私有的，只能通过 <code>emptyRecords()</code> 方法得到其对象。<code>MemoryRecords</code> 中有四个比较重要的方法。</p>
<ul>
<li><code>append()</code> 方法：先判断 <code>MomoryRecords</code> 是否为可写模式，然后调用 <code>Compressor.put*()</code> 方法，将消息数据写入 <code>ByteBuffer</code> 中。</li>
<li><code>hasRoomFor()</code> 方法：根据 <code>Compressor</code> 估计的已写字节数，估计 <code>MemoryRecords</code> 剩余空间是否足够写入指定的数据。注意，这里仅仅是估计，所以不一定准确，通过 <code>hasRoomFor()</code> 方法判断之后写入数据，也可能就会导致底层 <code>ByteBuffer</code> 出现扩容的情况。</li>
<li><code>close()</code> 方法：出现 <code>ByteBuffer</code> 扩容的情况时，<code>MemoryRecords.buffer</code> 字段与 <code>ByteBufferOutputStream.buffer</code> 字段所指向的不再是同一个 <code>ByteBuffer</code> 对象。在 <code>close()</code> 方法中，会将 <code>MemoryRecords.buffer</code> 字段指向扩容后的 <code>ByteBuffer</code> 对象。同时，将 <code>writbale</code> 设置为 <code>false</code> （即只读模式）</li>
<li><code>sizeInBytes()</code> 方法:对于可写的 <code>MemoryRecords</code> ，返回的是 <code>ByteBufferOutputStream.buffer</code> 字段的大小；对于只读 <code>MemoryRecords</code> ，返回的是 <code>MemoryRecords.buffer</code> 的大小。</li>
</ul>
<p><code>MemoryRecords</code> 还提供了迭代器，主要是用于在 <code>Consumer</code> 端读取其中的消息。</p>
<h2 id="RecordBatch"><a href="#RecordBatch" class="headerlink" title="RecordBatch"></a>RecordBatch</h2><p>在了解了 <code>MemoryRecords</code> 的具体实现之后，来分析 <code>RecordBatch</code> 类的实现。我们在前面所知，每个 <code>RecordBatch</code> 对象中封装了一个 <code>MemoryRecords</code> 对象，除此之外，还封装了很多控制信息和统计信息，接下来简单介绍一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录了保存的 Record 的个数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">recordCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 最大 Record 的字节数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">maxRecordSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 尝试发送当前 RecordBatch 的次数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">attempts</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> createdMs;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> drainedMs;</span><br><span class="line"><span class="comment">/* 最后一次尝试发送的时间戳 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> lastAttemptMs;</span><br><span class="line"><span class="comment">/* 指向用来存储数据的 MemoryRecords 对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> MemoryRecords records;</span><br><span class="line"><span class="comment">/* 当前 RecordBatch 中缓存的消息都会发送给此 TopicPartition */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TopicPartition topicPartition;</span><br><span class="line"><span class="comment">/* 标识 RecordBatch 状态的 Future 对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ProduceRequestResult produceFuture;</span><br><span class="line"><span class="comment">/* 最后一次向 RecordBatch 追加消息的时间戳 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> lastAppendTime;</span><br><span class="line"><span class="comment">/* Thunk 对象的集合 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thunk&gt; thunks;</span><br><span class="line"><span class="comment">/* 用来记录某消息在 RecordBatch 中的偏移量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">offsetCounter</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="comment">/* 是否正在重试。如果 RecordBatch 中的数据发送失败，则会重新尝试发送 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> retry;</span><br></pre></td></tr></table></figure>

<p>在下图中，以 <code>RecordBatch</code> 为中心，刻画了其相关类间的对应关系。</p>
<blockquote>
<p> 这里推荐一下 idea 的 <a target="_blank" rel="noopener" href="http://plantuml.com/sitemap">Plantuml</a> 这个插件</p>
</blockquote>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordBatch.png?raw=true" alt="RecordBatch"></p>
<p>下面我们来分析一下 <code>ProduceRequestResult</code> 这个类的功能。<code>ProduceRequestResult</code> 并未实现 <code>java.util.concurrent.Future</code> 接口，但是其通过包含一个 <code>count</code> 值为 1 的 <code>CountDownLatch</code> 对象，实现了类似于 <code>Future</code> 的功能。</p>
<p>当 <code>RecordBatch</code> 中全部的消息被正常响应、或超时、或关闭生产者时，会调用 <code>ProduceRequestResult.done()</code> 方法，将 <code>produceFuture</code> 标记为完成并通过 <code>ProduceRequestResult.error</code> 字段区分『异常完成』还是『正常完成』，之后调用 <code>CountDownLatch</code> 对象的 <code>countDown()</code> 方法。此时，会唤醒阻塞在 <code>CountDownLatch</code> 对象的 <code>await()</code> 方法的线程（这些线程通过 <code>ProduceRequestResult</code> 的 <code>await</code> 方法等待上述三个事件的发送）。</p>
<p>Kafka 的分区会为其中记录的消息分配一个 <code>offset</code> 并通过此 <code>offset</code> 维护消息顺序。在 <code>ProduceRequestResult</code> 中海油一个需要注意的字段 <code>baseOffset</code>，表示的是服务的为此 <code>RecordBatch</code> 中第一条消息分配的 <code>offset</code>，这样每个消息可以根据此 <code>offset</code> 以及自身在此 <code>RecordBatch</code> 中的相对偏移量，计算出其在服务端分区中的偏移量了。</p>
<p>在介绍 <code>Thunk</code> 类之前，先回顾一下 <code>KafkaProducer.send()</code> 方法的第二个参数，是一个 <code>Callback</code> 对象，它是针对单个消息的回调函数（每个消息对会有一个对应的 <code>Callback</code> 对象作为回调）。<code>RecordBatch.thunks</code> 字段可以理解为消息的回调对象队列，<code>Thunk</code> 中的 <code>callback</code> 字段就指向对应消息的 <code>Callback</code> 对象，其另一个字段 <code>future</code> 是 <code>FutureRecordMetadata</code> 类型。<code>FutureRecordMetadata</code> 类有两个关键字段。</p>
<ul>
<li><code>result</code>：<code>ProduceRequestResult</code> 类型，指向对应消息所在 <code>RecordBatch</code> 的 <code>produceFuture</code> 字段。</li>
<li><code>relativeOffset</code>：<code>long</code>类型，记录了对应消息在 <code>RecordBatch</code> 中的偏移量。</li>
</ul>
<p><code>FutureRecordMetadata</code> 实现了 <code>java.util.concurrent.Future</code> 接口，但其实现基本都是委托给了 <code>ProduceRequestResult</code> 对应的方法，由此可以看出，消息应该是按照 <code>RecordBatch</code> 进行发送和确认的。</p>
<p>当生产者已经收到某消息的响应时，<code>FutureRecordMetadata.get()</code> 方法就会返回 <code>RecordMetadata</code> 对象，其中包含消息在 <code>Partition</code> 中的 <code>offset</code> 等其他元数据，可供用户自定义 <code>Callback</code> 使用。</p>
<p>分析完 <code>RecordBatch</code> 依赖的组件，现在回来看看 <code>RecordBatch</code> 类的核心方法。<code>tryAppend()</code> 方法是最核心的方法，其功能是尝试将消息添加到当前的 <code>RecordBatch</code> 中缓存，代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FutureRecordMetadata <span class="title function_">tryAppend</span><span class="params">(<span class="type">long</span> timestamp, <span class="type">byte</span>[] key, <span class="type">byte</span>[] value, Callback callback, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">/* 估算剩余空间不足，前面说过，这不是一个准确值 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.records.hasRoomFor(key, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 向 MemoryRecords 中添加数据。注意，offsetCounter 是在 RecordBatch 中的偏移量 */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">checksum</span> <span class="operator">=</span> <span class="built_in">this</span>.records.append(offsetCounter++, timestamp, key, value);</span><br><span class="line">        <span class="comment">/*  更新统计信息 */</span></span><br><span class="line">        <span class="built_in">this</span>.maxRecordSize = Math.max(<span class="built_in">this</span>.maxRecordSize, Record.recordSize(key, value));</span><br><span class="line">        <span class="built_in">this</span>.lastAppendTime = now;</span><br><span class="line">        <span class="comment">/* 创建 FutureRecordMetadata 对象 */</span></span><br><span class="line">        <span class="type">FutureRecordMetadata</span> <span class="variable">future</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureRecordMetadata</span>(<span class="built_in">this</span>.produceFuture, <span class="built_in">this</span>.recordCount,</span><br><span class="line">                                                               timestamp, checksum,</span><br><span class="line">                                                               key == <span class="literal">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="literal">null</span> ? -<span class="number">1</span> : value.length);</span><br><span class="line">        <span class="comment">/* 将用户自定义 CallBack 和 FutureRecordMetadata 封装成 Thunk，保存到 thunks 集合中 */</span></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">            thunks.add(<span class="keyword">new</span> <span class="title class_">Thunk</span>(callback, future));</span><br><span class="line">        <span class="built_in">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>RecordBatch</code> 成功收到正常响应、或超市、或关闭生成者时，都会调用 <code>RecordBatch</code> 的 <code>done()</code> 方法。在 <code>done()</code> 方法中，会回调 <code>RecordBatch</code> 中全部消息的  <code>Callback</code> 回调，并调用其 <code>produceFuture</code> 字段的 <code>done()</code> 方法。<code>RecordBatch.done()</code> 方法的调用关系如下：</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordBatch-done.jpg?raw=true" alt="RecordBatch.done()调用链"></p>
<p>其代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">(<span class="type">long</span> baseOffset, <span class="type">long</span> timestamp, RuntimeException exception)</span> &#123;</span><br><span class="line">    log.trace(<span class="string">&quot;Produced messages to topic-partition &#123;&#125; with base offset offset &#123;&#125; and error: &#123;&#125;.&quot;</span>,</span><br><span class="line">              topicPartition,</span><br><span class="line">              baseOffset,</span><br><span class="line">              exception);</span><br><span class="line">    <span class="comment">// execute callbacks</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.thunks.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Thunk</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="built_in">this</span>.thunks.get(i);</span><br><span class="line">            <span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123; <span class="comment">/* 正常处理完成 */</span></span><br><span class="line">                <span class="comment">// If the timestamp returned by server is NoTimestamp, that means CreateTime is used. Otherwise LogAppendTime is used.</span></span><br><span class="line">                <span class="comment">/* 将服务端返回的信息（offset 和 timestamp）和消息的其他信息封装成 RecordMetadata */</span></span><br><span class="line">                <span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecordMetadata</span>(<span class="built_in">this</span>.topicPartition,  baseOffset, thunk.future.relativeOffset(),</span><br><span class="line">                                                             timestamp == Record.NO_TIMESTAMP ? thunk.future.timestamp() : timestamp,</span><br><span class="line">                                                             thunk.future.checksum(),</span><br><span class="line">                                                             thunk.future.serializedKeySize(),</span><br><span class="line">                                                             thunk.future.serializedValueSize());</span><br><span class="line">                <span class="comment">/* 调用详细对应的自定义 Callback */</span></span><br><span class="line">                thunk.callback.onCompletion(metadata, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 处理过程中出现异常，注意，第一个参数为 null，与上面情况刚好相反 */</span></span><br><span class="line">                thunk.callback.onCompletion(<span class="literal">null</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error executing user-provided callback on message for topic-partition &#123;&#125;:&quot;</span>, topicPartition, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 标识整个 RecordBatch 都已经处理完成 */</span></span><br><span class="line">    <span class="built_in">this</span>.produceFuture.done(topicPartition, baseOffset, exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h2><p><code>ByteBuffer</code> 的创建和释放是比较消耗资源的，为了实现内存的高效利用，基本上每个成熟的框架或工具都有一套内存管理机制。Kafka 客户端使用 <code>BufferPool</code> 来实现 <code>ByteBuffer</code> 的复用。</p>
<p>首先需要了解的是，每个 <code>BufferPool</code> 对象只针对特定大小（由<code>poolableSize</code> 字段指定）的 <code>ByteBuffer</code> 进行管理，对于其他大小的 <code>ByteBuffer</code> 并不会缓存进 <code>BufferPool</code> 。一般情况，我们会调整 <code>MemoryRecords</code> 的大小（<code>RecordAccumulator.batchSize</code> 字段指定），使得每个 <code>MemoryRecords</code> 可以缓存多条消息。但也有例外情况，当一条消息的字节数大于 <code>MemoryRecords</code> 时，就不会复用<code>BufferPool</code> 中缓存的 <code>ByteBuffer</code> ，而是例外分配 <code>ByteBuffer</code>，在它被使用完后也不会放入 <code>BufferPool</code> 进行管理，而是直接丢弃由 GC 回收。</p>
<p>下面介绍一下 <code>BufferPoll</code> 的关键字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录了整个 Pool 的大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> totalMemory;</span><br><span class="line"><span class="comment">/* 因为有多线程并发分配和回收 ByteBuffer，所以使用锁控制并发，保证线程安全 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/* 是一个 ArrayDeque&lt;ByteBuffer&gt; 队列，其中缓存了指定大小的 ByteBuffer 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; free;</span><br><span class="line"><span class="comment">/* 记录因申请不到足够空间而阻塞的线程，此队列中实际记录的是阻塞线程对应的 Condition 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Condition&gt; waiters;</span><br><span class="line"><span class="comment">/* 记录了可用的空间大小，这个空间是 totalMemory - free 列表的 ByteBuffer 大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> availableMemory;</span><br></pre></td></tr></table></figure>

<p><code>BufferPool.allocate()</code> 方法负责从缓冲池中申请 <code>ByteBuffer</code> ，<strong>当缓冲池中空间不足时，就会阻塞调用线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> size, <span class="type">long</span> maxTimeToBlockMs)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="built_in">this</span>.totalMemory)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Attempt to allocate &quot;</span> + size</span><br><span class="line">                                           + <span class="string">&quot; bytes, but there is a hard limit of &quot;</span></span><br><span class="line">                                           + <span class="built_in">this</span>.totalMemory</span><br><span class="line">                                           + <span class="string">&quot; on memory allocations.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.lock.lock(); <span class="comment">/* 同步加锁 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if we have a free buffer of the right size pooled</span></span><br><span class="line">        <span class="comment">/* 请求的是 poolableSize 指定大小的 ByteBuffer，且 free 中有空闲的 ByteBuffer */</span></span><br><span class="line">        <span class="keyword">if</span> (size == poolableSize &amp;&amp; !<span class="built_in">this</span>.free.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.free.pollFirst(); <span class="comment">/* 返回合适的 ByteBuffer */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当申请的空间大小不是 poolableSize，则执行下面的操作 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// now check if the request is immediately satisfiable with the</span></span><br><span class="line">        <span class="comment">// memory on hand or if we need to block</span></span><br><span class="line">        <span class="comment">/* free 队列中都是 poolableSize 大小的 ByteBuffer，可以直接计算整个 free 队列的空间 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">freeListSize</span> <span class="operator">=</span> <span class="built_in">this</span>.free.size() * <span class="built_in">this</span>.poolableSize;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.availableMemory + freeListSize &gt;= size) &#123;</span><br><span class="line">            <span class="comment">// we have enough unallocated or pooled memory to immediately</span></span><br><span class="line">            <span class="comment">// satisfy the request</span></span><br><span class="line">            <span class="comment">/* 为了让 availableMemory &gt; size，freeUp() 方法会从 free 队列中不断释放</span></span><br><span class="line"><span class="comment">             * ByteBuffer，直到 availableMemory 满足这次申请 */</span></span><br><span class="line">            freeUp(size);</span><br><span class="line">            <span class="built_in">this</span>.availableMemory -= size; <span class="comment">/* 减少 availableMemory */</span></span><br><span class="line">            lock.unlock(); <span class="comment">/* 解锁 */</span></span><br><span class="line">            <span class="comment">/* 这里没有用 free 队列中的 buffer，而是直接分配 size 大小的 HeapByteBuffer */</span></span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocate(size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有足够空间，只能阻塞了 */</span></span><br><span class="line">            <span class="comment">// we are out of memory and will have to block</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">accumulated</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Condition</span> <span class="variable">moreMemory</span> <span class="operator">=</span> <span class="built_in">this</span>.lock.newCondition();</span><br><span class="line">            <span class="type">long</span> <span class="variable">remainingTimeToBlockNs</span> <span class="operator">=</span> TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);</span><br><span class="line">            <span class="comment">/* 将 Condition 添加到 waiters 中 */</span></span><br><span class="line">            <span class="built_in">this</span>.waiters.addLast(moreMemory);</span><br><span class="line">            <span class="comment">// loop over and over until we have a buffer or have reserved</span></span><br><span class="line">            <span class="comment">// enough memory to allocate one</span></span><br><span class="line">            <span class="keyword">while</span> (accumulated &lt; size) &#123; <span class="comment">/* 循环等待 */</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">startWaitNs</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">                <span class="type">long</span> timeNs;</span><br><span class="line">                <span class="type">boolean</span> waitingTimeElapsed;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/* 阻塞 */</span></span><br><span class="line">                    waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">/* 异常，移除此线程对应的 Condition */</span></span><br><span class="line">                    <span class="built_in">this</span>.waiters.remove(moreMemory);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">/* 统计阻塞时间 */</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">endWaitNs</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">                    timeNs = Math.max(<span class="number">0L</span>, endWaitNs - startWaitNs);</span><br><span class="line">                    <span class="built_in">this</span>.waitTime.record(timeNs, time.milliseconds());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (waitingTimeElapsed) &#123; <span class="comment">/* 超时，报错 */</span></span><br><span class="line">                    <span class="built_in">this</span>.waiters.remove(moreMemory);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;Failed to allocate memory within the configured max blocking time &quot;</span> + maxTimeToBlockMs + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                remainingTimeToBlockNs -= timeNs;</span><br><span class="line">                <span class="comment">// check if we can satisfy this request from the free list,</span></span><br><span class="line">                <span class="comment">// otherwise allocate memory</span></span><br><span class="line">                <span class="comment">/* 请求的是 poolableSize 大小的 ByteBuffer，且 free 中有空间的 ByteBuffer */</span></span><br><span class="line">                <span class="keyword">if</span> (accumulated == <span class="number">0</span> &amp;&amp; size == <span class="built_in">this</span>.poolableSize &amp;&amp; !<span class="built_in">this</span>.free.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// just grab a buffer from the free list</span></span><br><span class="line">                    buffer = <span class="built_in">this</span>.free.pollFirst();</span><br><span class="line">                    accumulated = size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 先分配一部分空间，并继续等待空闲空间 */</span></span><br><span class="line">                    <span class="comment">// we&#x27;ll need to allocate memory, but we may only get</span></span><br><span class="line">                    <span class="comment">// part of what we need on this iteration</span></span><br><span class="line">                    freeUp(size - accumulated);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">got</span> <span class="operator">=</span> (<span class="type">int</span>) Math.min(size - accumulated, <span class="built_in">this</span>.availableMemory);</span><br><span class="line">                    <span class="built_in">this</span>.availableMemory -= got;</span><br><span class="line">                    accumulated += got;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remove the condition for this thread to let the next thread</span></span><br><span class="line">            <span class="comment">// in line start getting memory</span></span><br><span class="line">            <span class="comment">/* 已经成功分配空间，移除 Condition */</span></span><br><span class="line">            <span class="type">Condition</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="built_in">this</span>.waiters.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (removed != moreMemory)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Wrong condition: this shouldn&#x27;t happen.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// signal any additional waiters if there is more memory left</span></span><br><span class="line">            <span class="comment">// over for them</span></span><br><span class="line">            <span class="comment">/* 还是要用空闲空间，就唤醒下一个线程 */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.availableMemory &gt; <span class="number">0</span> || !<span class="built_in">this</span>.free.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.waiters.isEmpty())</span><br><span class="line">                    <span class="built_in">this</span>.waiters.peekFirst().signal();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unlock and return the buffer</span></span><br><span class="line">            lock.unlock(); <span class="comment">/* 解锁 */</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> ByteBuffer.allocate(size);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> buffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">/* 解锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">            lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了 <code>allocate()</code> 方法的实现后，继续分享 <code>deallocate()</code> 方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deallocate</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">/* 加锁 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 释放的 ByteBuffer 的大小是 poolableSize，放入 free 队列进行管理 */</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="built_in">this</span>.poolableSize &amp;&amp; size == buffer.capacity()) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="built_in">this</span>.free.add(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 释放的 ByteBuffer 大小不是 poolableSize，不会复用 ByteBuffer，仅修改 availableMemory 的值 */</span></span><br><span class="line">            <span class="built_in">this</span>.availableMemory += size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 唤醒一个因空间不足而阻塞的线程 */</span></span><br><span class="line">        <span class="type">Condition</span> <span class="variable">moreMem</span> <span class="operator">=</span> <span class="built_in">this</span>.waiters.peekFirst();</span><br><span class="line">        <span class="keyword">if</span> (moreMem != <span class="literal">null</span>)</span><br><span class="line">            moreMem.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">/* 解锁 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RecordAccumulator"><a href="#RecordAccumulator" class="headerlink" title="RecordAccumulator"></a>RecordAccumulator</h2><p>介绍完了 <code>MemoryRecord</code>、<code>RecordBatch</code> 以及 <code>BufferPool</code> 的工作机制，再来看 <code>RecordAccumulator</code> 的实现就比较简单了。先来看看 <code>RecordAccumulator</code> 中的关键字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定每个 RecordBatch 底层 ByteBuffer 的大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> batchSize;</span><br><span class="line"><span class="comment">/* 压缩类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CompressionType compression;</span><br><span class="line"><span class="comment">/* BufferPool 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BufferPool free;</span><br><span class="line"><span class="comment">/* TopicPartition 与 RecordBatch 集合的映射关系，类型是 CopyOnWriteMap，是线程安全的结合，</span></span><br><span class="line"><span class="comment"> * 但其中的 Deque 是 ArrayDeque 类型，是非线程安全的结合。追加新消息或发送 RecordBatch</span></span><br><span class="line"><span class="comment"> * 的时候，需要同步加锁。每个 Deque 都保持了发往对应 TopicPartition 的 RecordBatch 集合*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; batches;</span><br><span class="line"><span class="comment">/* 未发送完成 RecordBatch 集合，底层通过 Set&lt;RecordBatch&gt; 实现 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IncompleteRecordBatches incomplete;</span><br><span class="line"><span class="comment">/* 使用 drain 方法批量导出 RecordBatch 时，为了防止饥饿，使用 drainIndex 记录上次发送停止时的位置，</span></span><br><span class="line"><span class="comment"> * 下次继续从此位置开始发送 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> drainIndex;</span><br></pre></td></tr></table></figure>

<p><code>KafkaProducer.send()</code> 方法最终会调用 <code>RecordsAccumulator.append()</code> 方法将消息追加到 <code>RecordAccumulator</code> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RecordAppendResult <span class="title function_">append</span><span class="params">(TopicPartition tp,</span></span><br><span class="line"><span class="params">                                 <span class="type">long</span> timestamp,</span></span><br><span class="line"><span class="params">                                 <span class="type">byte</span>[] key,</span></span><br><span class="line"><span class="params">                                 <span class="type">byte</span>[] value,</span></span><br><span class="line"><span class="params">                                 Callback callback,</span></span><br><span class="line"><span class="params">                                 <span class="type">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// We keep track of the number of appending thread to make sure we do not miss batches in</span></span><br><span class="line">    <span class="comment">// abortIncompleteBatches().</span></span><br><span class="line">    <span class="comment">/* 统计正在向 RecordsAccumulator 中追加数据的线程数 */</span></span><br><span class="line">    appendsInProgress.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 1. 查找 TopicPartition 对应的 Deque */</span></span><br><span class="line">        <span class="comment">// check if we have an in-progress batch</span></span><br><span class="line">        Deque&lt;RecordBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123; <span class="comment">/* 2. 对 Deque 对象加锁 */</span></span><br><span class="line">            <span class="comment">/* 边界检查 */</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot send after the producer is closed.&quot;</span>);</span><br><span class="line">            <span class="comment">/* 3. 向 Deque 中最后一个 RecordBatch 追加 Record */</span></span><br><span class="line">            <span class="type">RecordAppendResult</span> <span class="variable">appendResult</span> <span class="operator">=</span> tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> appendResult; <span class="comment">/* 5. 追加成功直接返回 */</span></span><br><span class="line">        &#125; <span class="comment">/* 4. synchronized 块结束，自动解锁 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// we don&#x27;t have an in-progress record batch try to allocate a new batch</span></span><br><span class="line">        <span class="comment">/* 6. 追加失败，从 BufferPool 中申请新空间 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="built_in">this</span>.batchSize, Records.LOG_OVERHEAD + Record.recordSize(key, value));</span><br><span class="line">        log.trace(<span class="string">&quot;Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;&quot;</span>, size, tp.topic(), tp.partition());</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> free.allocate(size, maxTimeToBlock);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">            <span class="comment">/* 边界检查 */</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot send after the producer is closed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 7. 对 Deque 加锁后，再次调用 tryAppend() 方法尝试追加 Record */</span></span><br><span class="line">            <span class="type">RecordAppendResult</span> <span class="variable">appendResult</span> <span class="operator">=</span> tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="literal">null</span>) &#123; <span class="comment">/* 8. 追加成功，则返回 */</span></span><br><span class="line">                <span class="comment">// Somebody else found us a batch, return the one we waited for! Hopefully this doesn&#x27;t happen often...</span></span><br><span class="line">                free.deallocate(buffer); <span class="comment">/* 释放 7 申请的新空间 */</span></span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">MemoryRecords</span> <span class="variable">records</span> <span class="operator">=</span> MemoryRecords.emptyRecords(buffer, compression, <span class="built_in">this</span>.batchSize);</span><br><span class="line">            <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecordBatch</span>(tp, records, time.milliseconds());</span><br><span class="line">            <span class="comment">/* 9. 在新创建的 RecordBatch 中追加 Record，并将其添加到 batches 集合中 */</span></span><br><span class="line">            <span class="type">FutureRecordMetadata</span> <span class="variable">future</span> <span class="operator">=</span> Utils.notNull(batch.tryAppend(timestamp, key, value, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">            dq.addLast(batch);</span><br><span class="line">            <span class="comment">/* 10. 将新建的 RecordBatch 追加到 incomplete 集合 */</span></span><br><span class="line">            incomplete.add(batch);</span><br><span class="line">            <span class="comment">/* 12. 返回 RecordAppendResult */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RecordAppendResult</span>(future, dq.size() &gt; <span class="number">1</span> || batch.records.isFull(), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="comment">/* 11. synchronized 块结束，解锁 */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        appendsInProgress.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面之所以分为两个 <code>synchronized</code> 是因为向 <code>BufferPool</code> 申请新 <code>ByteBuffer</code> 的时候，可能会导致阻塞。我们假设在一个 <code>synchronized</code> 中完成上面所有的追加操作，有下面的场景：线程 1 发送的消息比较大，需要向 <code>BufferPool</code> 申请新空间，而此时 <code>BufferPool</code> 空间不足，线程 1 在 <code>BufferPool</code> 上等待，此时它依然持有对应 <code>Deque</code> 的锁；线程 2 发送的消息较小，<code>Deque</code> 最后一个 <code>RecordBatch</code> 剩余空间够用，但是由于线程 1 未释放 <code>Deque</code> 的锁，所以也需要一起等待。若线程 2 这样的线程比较多，就会造成很多不必要的线程阻塞，降低了吞吐量。</p>
<p>第二次加锁后重试，是为了防止多个线程并发向 <code>BufferPool</code> 申请空间后，造成内部碎片。</p>
<p>现在回到 <code>KafkaProducer.doSend()</code> 方法，<code>doSend()</code> 方法的最后一步就是判断此次向 <code>RecordAccumulator</code> 中追加消息后是否满足唤醒 <code>Sender</code> 线程条件，这里唤醒 <code>Sender</code> 线程的条件是消息所在队列的最后一个 <code>RecordBatch</code> 满了或此队列中不止一个 <code>RecordBatch</code>。</p>
<p>在客户端将消息发送给服务端之前，会调用 <code>RecordAccumulator.ready()</code> 方法获取集群中符合发送消息条件的节点集合。这些条件是站在 <code>RecordAccumulator</code> 的家都对集群中的 <code>Node</code> 进行筛选，具体条件如下：</p>
<ol>
<li><code>Deque</code> 中有多个 <code>RecordBatch</code> 或是第一个 <code>RecordBatch</code> 是否满了</li>
<li>是否超时了</li>
<li>是否有其他线程在等待 <code>BufferPool</code> 释放空间（即 <code>BufferPool</code> 的空间耗尽了）</li>
<li>是否有线程正在等待 <code>flush</code> 操作完成</li>
<li><code>Sender</code> 线程准备关闭</li>
</ol>
<p>下面来看一下 <code>ready</code> 的代码，它会遍历 <code>batches</code> 集合中每个分区，首先查找当前分区 <code>Leader</code> 副本所在的 <code>Node</code> ，如果满足上述五个条件，则将此 <code>Node</code> 信息记录到 <code>readyNodes</code> 集合中。遍历完成后返回 <code>ReadyCheckResult</code> 对象，其中记录了满足发送条件的 <code>Node</code> 集合、在遍历过程中是否找不到 <code>Leader</code> 副本的分区（也可以认为是 <code>Metadata</code> 中当前的元数据过时了）、下次调用 <code>ready()</code> 方法进行检查的时间间隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReadyCheckResult <span class="title function_">ready</span><span class="params">(Cluster cluster, <span class="type">long</span> nowMs)</span> &#123;</span><br><span class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">/* 用来记录可以向那些 Node 节点发送数据 */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nextReadyCheckDelayMs</span> <span class="operator">=</span> Long.MAX_VALUE; <span class="comment">/* 记录下次需要调用 ready() 方法的时间间隔 */</span></span><br><span class="line">     <span class="comment">/* 根据 Metadata 元数据中记录有找不到 Leader 副本的分区 */</span></span><br><span class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否有现车在阻塞等待 BufferPool 释放空间 */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exhausted</span> <span class="operator">=</span> <span class="built_in">this</span>.free.queued() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 下面遍历 batches 集合，对其中每个分区的 Leader 副本所在的 Node 都进行判断 */</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; entry : <span class="built_in">this</span>.batches.entrySet()) &#123;</span><br><span class="line">        <span class="type">TopicPartition</span> <span class="variable">part</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        Deque&lt;RecordBatch&gt; deque = entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">leader</span> <span class="operator">=</span> cluster.leaderFor(part); <span class="comment">/* 查找分区的 Leader 副本所在的 Node */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123; <span class="comment">/* 加锁读取 deque 的元素 */</span></span><br><span class="line">            <span class="comment">/* 根据 Cluster 的信息检查 Leader，Leader 找不到，肯定不能发送消息 */</span></span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; !deque.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></span><br><span class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></span><br><span class="line">                <span class="comment">/* 这里不为空之后会触发 Metadata 的更新 */</span></span><br><span class="line">                unknownLeaderTopics.add(part.topic());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !muted.contains(part)) &#123;</span><br><span class="line">                <span class="comment">/* 只取 Deque 中的第一个 RecordBatch */</span></span><br><span class="line">                <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (batch != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">backingOff</span> <span class="operator">=</span> batch.attempts &gt; <span class="number">0</span> &amp;&amp; batch.lastAttemptMs + retryBackoffMs &gt; nowMs;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">waitedTimeMs</span> <span class="operator">=</span> nowMs - batch.lastAttemptMs;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeToWaitMs</span> <span class="operator">=</span> backingOff ? retryBackoffMs : lingerMs;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeLeftMs</span> <span class="operator">=</span> Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">/* Deque 中有多个 RecordBatch 或是第一个 RecordBatch 是否满了 */</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">full</span> <span class="operator">=</span> deque.size() &gt; <span class="number">1</span> || batch.records.isFull();</span><br><span class="line">                    <span class="comment">/* 是否超时了 */</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">expired</span> <span class="operator">=</span> waitedTimeMs &gt;= timeToWaitMs;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">sendable</span> <span class="operator">=</span> full || expired</span><br><span class="line">                            || exhausted <span class="comment">/* 是否有其他线程在等待 BufferPool 释放空间（即 BufferPool 的空间耗尽了）*/</span></span><br><span class="line">                            || closed  <span class="comment">/* Sender 线程准备关闭 */</span></span><br><span class="line">                            || flushInProgress(); <span class="comment">/* 是否有线程正在等待 flush 操作完成 */</span></span><br><span class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;</span><br><span class="line">                        readyNodes.add(leader);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></span><br><span class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></span><br><span class="line">                        <span class="comment">// since we&#x27;ll just wake up and then sleep again for the remaining time.</span></span><br><span class="line">                        <span class="comment">/* 记录下次需要调用 ready() 方法检查的时间间隔 */</span></span><br><span class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadyCheckResult</span>(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>RecordAccumulator.ready()</code> 方法得到 <code>readyNodes</code> 集合后，此集合还要经过 <code>NetworkClient</code> 的过滤之后，才能得到最终能够发送消息的 <code>Node</code> 集合。</p>
<p><code>RecordAccumulator.drain()</code> 方法会根据上述 <code>Node</code> 集合获取要发送的消息，返回 <code>Map&lt;Integer, List&lt;RecordBatch&gt;&gt;</code> 集合，<code>key</code> 是 <code>NodeId</code>，<code>value</code> 是待发送的 <code>RecordBatch</code> 集合。<code>drain</code> 方法也是由 <code>Sender</code> 线程调用的。</p>
<p><code>drain</code> 方法的核心逻辑是进行映射的转换：将 <code>RecordAccumulatro</code> 记录的 <code>TopicPartition -&gt; RecordBatch</code> 集合的映射，转换成了 <code>NodeId -&gt; RecordBatch</code> 集合的映射。</p>
<p>为什么需要这次转换？在网络 I&#x2F;O 层面，生产者是面向 <code>Node</code> 节点发送消息数据，它只建立到 <code>Node</code> 的连接并发送数据，并不关心这些数据数据哪个 <code>TopicPartition</code> ；而是调用 <code>KafkaProducer</code> 的上层业务逻辑中，则是按照 <code>TopicPartition</code> 的 <code>Node</code> 节点上。在之后介绍 <code>Sender</code> 线程的时候会发现，它每次向每个 <code>Node</code> 节点至多发送一个 <code>ClientRequest</code> 请求，其中封装了追加到此 <code>Node</code> 节点上多个分区的消息，待请求到达服务端后，由 Kafka 对请求进行解析。</p>
<p>下面来看看 <code>drain</code> 方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;RecordBatch&gt;&gt; <span class="title function_">drain</span><span class="params">(Cluster cluster,</span></span><br><span class="line"><span class="params">                                             Set&lt;Node&gt; nodes,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> maxSize,</span></span><br><span class="line"><span class="params">                                             <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 转换之后的结果 */</span></span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodes) &#123; <span class="comment">/* 遍历指定的 ready Node 集合 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 获取当前 Node 上的分区集合 */</span></span><br><span class="line">        List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());</span><br><span class="line">        <span class="comment">/* 记录要发送的 RecordBatch */</span></span><br><span class="line">        List&lt;RecordBatch&gt; ready = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/* to make starvation  less likely this loop doesn&#x27;t start at 0 */</span></span><br><span class="line">        <span class="comment">/* drainIndex 是 batches 的下标，记录上次发送停止时的位置，下次继续从此位置开始发送</span></span><br><span class="line"><span class="comment">         * 若一直从索引 0 的队列开始发送，可能会出现一直发送前几个分区的消息的情况，造成其他分区饥饿 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> drainIndex = drainIndex % parts.size();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">PartitionInfo</span> <span class="variable">part</span> <span class="operator">=</span> parts.get(drainIndex); <span class="comment">/* 获取分区详细情况 */</span></span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(part.topic(), part.partition());</span><br><span class="line">            <span class="comment">// Only proceed if the partition has no in-flight batches.</span></span><br><span class="line">            <span class="keyword">if</span> (!muted.contains(tp)) &#123;</span><br><span class="line">                <span class="comment">/* 获取对应的 RecordBatch 队列 */</span></span><br><span class="line">                Deque&lt;RecordBatch&gt; deque = getDeque(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(part.topic(), part.partition()));</span><br><span class="line">                <span class="comment">/* 边界检查 */</span></span><br><span class="line">                <span class="keyword">if</span> (deque != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">                        <span class="type">RecordBatch</span> <span class="variable">first</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                        <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">backoff</span> <span class="operator">=</span> first.attempts &gt; <span class="number">0</span> &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;</span><br><span class="line">                            <span class="comment">// Only drain the batch if it is not during backoff period.</span></span><br><span class="line">                            <span class="keyword">if</span> (!backoff) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (size + first.records.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;</span><br><span class="line">                                    <span class="comment">// there is a rare case that a single batch size is larger than the request size due</span></span><br><span class="line">                                    <span class="comment">// to compression; in this case we will still eventually send this batch in a single</span></span><br><span class="line">                                    <span class="comment">// request</span></span><br><span class="line">                                    <span class="keyword">break</span>; <span class="comment">/* 队列已满，结束循环，一般是一个请求的大小 */</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">/* 从队列中获取一个 RecordBatch，并将这个 RecordBatch 放到 ready 集合中 */</span></span><br><span class="line">                                    <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">                                    <span class="comment">/* 关闭 Compressor 及底层输出流，并将 MemoryRecords 设置为只读 */</span></span><br><span class="line">                                    batch.records.close();</span><br><span class="line">                                    size += batch.records.sizeInBytes();</span><br><span class="line">                                    ready.add(batch);</span><br><span class="line">                                    batch.drainedMs = now;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 更新 drainIndex */</span></span><br><span class="line">            <span class="built_in">this</span>.drainIndex = (<span class="built_in">this</span>.drainIndex + <span class="number">1</span>) % parts.size();</span><br><span class="line">        &#125; <span class="keyword">while</span> (start != drainIndex);</span><br><span class="line">        batches.put(node.id(), ready);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在上面代码中，只从每个队列中取出一个 <code>RecordBatch</code> 放到 <code>ready</code> 集合中，这也是为了防止饥饿，提高系统的可用性。</p>
<p><code>RecordAccumulator</code> 的工作原理到这里就介绍完了，整个 <code>KafkaProducer.send()</code> 方法过程中用到的所有组件也都分析完了。后面将分析的是 <code>Sender</code> 线程是如何发送消息的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"># 分布式与中间件</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/12/18/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-AOP/" rel="prev" title="Spring源码分析-AOP">
                  <i class="fa fa-angle-left"></i> Spring源码分析-AOP
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/01/30/%E5%85%B3%E4%BA%8E-asyncio-%E7%9A%84%E5%96%83%E5%96%83%E8%87%AA%E8%AF%AD/" rel="next" title="关于 asyncio 的喃喃自语">
                  关于 asyncio 的喃喃自语 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘冰鉴</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
