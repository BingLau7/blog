<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Res severa est verum gaudium.">
<meta property="og:type" content="website">
<meta property="og:title" content="村里最好的博客">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="村里最好的博客">
<meta property="og:description" content="Res severa est verum gaudium.">
<meta property="og:locale">
<meta property="article:author" content="刘冰鉴">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>村里最好的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">村里最好的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘冰鉴</p>
  <div class="site-description" itemprop="description">Res severa est verum gaudium.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/03/21/yield%E4%B8%8Eyield-from%E5%A4%87%E5%BF%98%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/03/21/yield%E4%B8%8Eyield-from%E5%A4%87%E5%BF%98%E5%BD%95/" class="post-title-link" itemprop="url">yield与yield from备忘录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-03-21 16:49:05" itemprop="dateCreated datePublished" datetime="2017-03-21T16:49:05+08:00">2017-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对于 <code>yield</code>与<code>yield from</code>的语法，官方给出的解释<a target="_blank" rel="noopener" href="https://docs.python.org/3.6/reference/simple_stmts.html#yield">Link</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/03/21/yield%E4%B8%8Eyield-from%E5%A4%87%E5%BF%98%E5%BD%95/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/03/05/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/03/05/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">浅谈动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-03-05 16:49:34" itemprop="dateCreated datePublished" datetime="2017-03-05T16:49:34+08:00">2017-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本篇是个人动态规划笔记。</p>
<h3 id="应用动态规划方法："><a href="#应用动态规划方法：" class="headerlink" title="应用动态规划方法："></a>应用动态规划方法：</h3><ol>
<li>刻画一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造一个最优解</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/03/05/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/02/15/%E5%88%86%E6%9E%90%E4%B8%80%E6%B3%A2-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/02/15/%E5%88%86%E6%9E%90%E4%B8%80%E6%B3%A2-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">分析一波 Java 线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-02-15 16:51:43" itemprop="dateCreated datePublished" datetime="2017-02-15T16:51:43+08:00">2017-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Executors-executeCase"><a href="#Executors-executeCase" class="headerlink" title="Executors.executeCase"></a>Executors.executeCase</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a thread pool that reuses a fixed number of threads operating</span></span><br><span class="line"><span class="comment">         * off a shared unbounded queue, using the provided ThreadFactory to create</span></span><br><span class="line"><span class="comment">         * new threads when needed. At any point, at most nThreads threads will be</span></span><br><span class="line"><span class="comment">         * active processing tasks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiftOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// Default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> taskCount++;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">(<span class="type">int</span> countDown)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">status</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;(&quot;</span> +</span><br><span class="line">                (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">&quot;Liftoff!&quot;</span>) + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/02/15/%E5%88%86%E6%9E%90%E4%B8%80%E6%B3%A2-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/02/01/Python%E6%95%B4%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/02/01/Python%E6%95%B4%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">Python整型对象创建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-02-01 16:50:44" itemprop="dateCreated datePublished" datetime="2017-02-01T16:50:44+08:00">2017-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>Python3 中无论整数还是长整数统统使用 PyLongObject 类型来代替</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Long integer representation.</span></span><br><span class="line"><span class="comment">   The absolute value of a number is equal to</span></span><br><span class="line"><span class="comment">   	SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)</span></span><br><span class="line"><span class="comment">   Negative numbers are represented with ob_size &lt; 0;</span></span><br><span class="line"><span class="comment">   zero is represented by ob_size == 0.</span></span><br><span class="line"><span class="comment">   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant</span></span><br><span class="line"><span class="comment">   digit) is never zero.  Also, in all cases, for all valid i,</span></span><br><span class="line"><span class="comment">   	0 &lt;= ob_digit[i] &lt;= MASK.</span></span><br><span class="line"><span class="comment">   The allocation function takes care of allocating extra memory</span></span><br><span class="line"><span class="comment">   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   CAUTION:  Generic code manipulating subtypes of PyVarObject has to</span></span><br><span class="line"><span class="comment">   aware that ints abuse  ob_size&#x27;s sign bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">	PyObject_VAR_HEAD</span><br><span class="line">	digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Nothing is actually declared to be a PyObject, but every pointer to</span></span><br><span class="line"><span class="comment"> * a Python object can be cast to a PyObject*.  This is inheritance built</span></span><br><span class="line"><span class="comment"> * by hand.  Similarly every pointer to a variable-size Python object can,</span></span><br><span class="line"><span class="comment"> * in addition, be cast to PyVarObject*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>由于<code>Py_TRACE_REFS</code>在release状态下是不会定义的，所以整个数据结构就会特别简单:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p>小数优化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class="line"><span class="comment">/* Small integers are preallocated in this array so that they</span></span><br><span class="line"><span class="comment">   can be shared.</span></span><br><span class="line"><span class="comment">   The integers that are preallocated are those in the range</span></span><br><span class="line"><span class="comment">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">Py_ssize_t quick_int_allocs, quick_neg_int_allocs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">get_small_int</span><span class="params">(sdigit ival)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="keyword">if</span> (ival &gt;= <span class="number">0</span>)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_SMALL_INT(ival) \</span></span><br><span class="line"><span class="meta">    do <span class="keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123; \</span></span><br><span class="line"><span class="meta">        return get_small_int((sdigit)ival); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>创建函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PyLongObject *</span><br><span class="line">_PyLong_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *result;</span><br><span class="line">    <span class="comment">/* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +</span></span><br><span class="line"><span class="comment">       sizeof(digit)*size.  Previous incarnations of this code used</span></span><br><span class="line"><span class="comment">       sizeof(PyVarObject) instead of the offsetof, but this risks being</span></span><br><span class="line"><span class="comment">       incorrect in the presence of padding between the PyVarObject header</span></span><br><span class="line"><span class="comment">       and the digits. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;too many digits in integer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// offsetof(type, member-designator) 会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。</span></span><br><span class="line">    result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +</span><br><span class="line">                             size*<span class="keyword">sizeof</span>(digit));</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>PyObject_MALLOC</code>是与 <code>WITH_PYMALLOC</code>定义相关</p>
<blockquote>
<p> Pymalloc, a specialized object allocator written by Vladimir Marangozov, was a feature added to Python 2.1. Pymalloc is intended to be faster than the system malloc() and to have less memory overhead for allocation patterns typical of Python programs. The allocator uses C’s malloc() function to get large pools of memory and then fulfills smaller memory requests from these pools.</p>
<p> In 2.1 and 2.2, pymalloc was an experimental feature and wasn’t enabled by default; you had to explicitly enable it when compiling Python by providing the <strong>–with-pymalloc</strong> option to the <strong>configure</strong> script. In 2.3, pymalloc has had further enhancements and is now enabled by default; you’ll have to supply**–without-pymalloc** to disable it.</p>
</blockquote>
<p>可以看出这东西是默认开启的，所以从代码可知调用的是<code>_PyObject_Malloc</code>方法，再追踪源码发现其最终调用的是如下方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyObject_Malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyObject.<span class="built_in">malloc</span>(_PyObject.ctx, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_PyObject_Malloc(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_Alloc(<span class="number">0</span>, ctx, <span class="number">1</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc.  Note that nbytes==0 tries to return a non-NULL pointer, distinct</span></span><br><span class="line"><span class="comment"> * from all other currently live pointers.  This may not be possible.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The basic blocks are ordered by decreasing execution frequency,</span></span><br><span class="line"><span class="comment"> * which minimizes the number of jumps in the most common cases,</span></span><br><span class="line"><span class="comment"> * improves branching prediction and instruction scheduling (small</span></span><br><span class="line"><span class="comment"> * block allocations typically result in a couple of instructions).</span></span><br><span class="line"><span class="comment"> * Unless the optimizer reorders everything, being too smart...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_PyObject_Alloc(<span class="type">int</span> use_calloc, <span class="type">void</span> *ctx, <span class="type">size_t</span> nelem, <span class="type">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    解释一下 ctx, 这是 PyMemAllocatorEx 的 ctx，</span></span><br><span class="line"><span class="comment">   static PyMemAllocatorEx _PyObject = &#123;</span></span><br><span class="line"><span class="comment">#ifdef Py_DEBUG</span></span><br><span class="line"><span class="comment">    &amp;_PyMem_Debug.obj, PYDBG_FUNCS</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">    NULL, PYOBJ_FUNCS</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">     来定义，可以看出，这个是为了 Debug 来操作的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> nbytes;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录分配了一块 block</span></span><br><span class="line">    _Py_AllocatedBlocks++;</span><br><span class="line"></span><br><span class="line">    assert(nelem &lt;= PY_SSIZE_T_MAX / elsize);</span><br><span class="line">    <span class="comment">// 创建对象个数乘以创建每个对象所需要的字节数</span></span><br><span class="line">    nbytes = nelem * elsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启 valgrind 来调试程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_VALGRIND</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(running_on_valgrind == <span class="number">-1</span>))</span><br><span class="line">        running_on_valgrind = RUNNING_ON_VALGRIND;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(running_on_valgrind))</span><br><span class="line">        <span class="keyword">goto</span> redirect;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nelem == <span class="number">0</span> || elsize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> redirect;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存与大块内存分配分界处</span></span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">        <span class="comment">// 这里有些不能理解，看注释是</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Locking</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * To reduce lock contention, it would probably be better to refine the</span></span><br><span class="line"><span class="comment">         * crude function locking with per size class locking. I&#x27;m not positive</span></span><br><span class="line"><span class="comment">         * however, whether it&#x27;s worth switching to such locking policy because</span></span><br><span class="line"><span class="comment">         * of the performance penalty it might introduce.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The following macros describe the simplest (should also be the fastest)</span></span><br><span class="line"><span class="comment">         * lock object on a particular platform and the init/fini/lock/unlock</span></span><br><span class="line"><span class="comment">         * operations on it. The locks defined here are not expected to be recursive</span></span><br><span class="line"><span class="comment">         * because it is assumed that they will always be called in the order:</span></span><br><span class="line"><span class="comment">         * INIT, [LOCK, UNLOCK]*, FINI.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Python&#x27;s threads are serialized, so object malloc locking is disabled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 但是不能理解其加锁方式</span></span><br><span class="line">        LOCK();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Most frequent paths first</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 得到 size_class_index</span></span><br><span class="line">        size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">        <span class="comment">// 从 userdpool 中找到匹配的pool然后准备存到里面去</span></span><br><span class="line">        pool = usedpools[size + size];</span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">            <span class="comment">// 这个是最终都要进入的地方</span></span><br><span class="line">            <span class="comment">// 如果 usedpool  中有可用的 pool</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * There is a used pool for this size class.</span></span><br><span class="line"><span class="comment">             * Pick up the head block of its free list.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ++pool-&gt;ref.count;</span><br><span class="line">            bp = pool-&gt;freeblock;</span><br><span class="line">            assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                    <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Reached the end of the free list, try to extend it.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">                <span class="comment">/* There is room for another block. */</span></span><br><span class="line">                pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                                  pool-&gt;nextoffset;</span><br><span class="line">                pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">                *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                    <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Pool is full, unlink from used pools. */</span></span><br><span class="line">            next = pool-&gt;nextpool;</span><br><span class="line">            pool = pool-&gt;prevpool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">            <span class="comment">// bp 返回的实际是一个地址，这个地址之后有将近 4KB 的内存实际上都是可用的，</span></span><br><span class="line">            <span class="comment">// 但是可用肯定申请内存的函数只会使用[bp, bp+size] 这个区间的内存，</span></span><br><span class="line">            <span class="comment">// 这是由 size class index 可用保证的。</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//usedpools中无可用pool，尝试获取empty状态pool</span></span><br><span class="line">        <span class="comment">/* There isn&#x27;t a pool of the right size class immediately</span></span><br><span class="line"><span class="comment">         * available:  use a free pool.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果usable_arenas链表为空，则创建链表</span></span><br><span class="line">            <span class="comment">/* No arena has a free pool:  allocate a new arena. */</span></span><br><span class="line">        <span class="comment">// WITH_MEMORY_LIMITS 编译时候打开会激活 SMALL_MEMORY_LIMIT 符号，该符号限制了 arena 的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_MEMORY_LIMITS</span></span><br><span class="line">            <span class="keyword">if</span> (narenas_currently_allocated &gt;= MAX_ARENAS) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">goto</span> redirect;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 申请新的arena_object，并放入usable_arenas链表</span></span><br><span class="line">            usable_arenas = new_arena();</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">goto</span> redirect;</span><br><span class="line">            &#125;</span><br><span class="line">            usable_arenas-&gt;nextarena =</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to get a cached free pool. */</span></span><br><span class="line">        <span class="comment">// 从usable_arenas链表中第一个arena的freepools中抽取一个可用的pool</span></span><br><span class="line">        pool = usable_arenas-&gt;freepools;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Unlink from cached pools. */</span></span><br><span class="line">            usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This arena already had the smallest nfreepools</span></span><br><span class="line"><span class="comment">             * value, so decreasing nfreepools doesn&#x27;t change</span></span><br><span class="line"><span class="comment">             * that, and we don&#x27;t need to rearrange the</span></span><br><span class="line"><span class="comment">             * usable_arenas list.  However, if the arena has</span></span><br><span class="line"><span class="comment">             * become wholly allocated, we need to remove its</span></span><br><span class="line"><span class="comment">             * arena_object from usable_arenas.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//调整usable_arenas链表中第一个arena中的可用pool数量</span></span><br><span class="line">            <span class="comment">//如果调整后数量为0，则将该arena从usable_arenas链表中摘除</span></span><br><span class="line">            --usable_arenas-&gt;nfreepools;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* Wholly allocated:  remove. */</span></span><br><span class="line">                assert(usable_arenas-&gt;freepools == <span class="literal">NULL</span>);</span><br><span class="line">                assert(usable_arenas-&gt;nextarena == <span class="literal">NULL</span> ||</span><br><span class="line">                       usable_arenas-&gt;nextarena-&gt;prevarena ==</span><br><span class="line">                       usable_arenas);</span><br><span class="line"></span><br><span class="line">                usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">                <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                    assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* nfreepools &gt; 0:  it must be that freepools</span></span><br><span class="line"><span class="comment">                 * isn&#x27;t NULL, or that we haven&#x27;t yet carved</span></span><br><span class="line"><span class="comment">                 * off all the arena&#x27;s pools for the first</span></span><br><span class="line"><span class="comment">                 * time.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                assert(usable_arenas-&gt;freepools != <span class="literal">NULL</span> ||</span><br><span class="line">                       usable_arenas-&gt;pool_address &lt;=</span><br><span class="line">                       (block*)usable_arenas-&gt;address +</span><br><span class="line">                           ARENA_SIZE - POOL_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line">        init_pool:</span><br><span class="line">            <span class="comment">/* Frontlink to used pools. */</span></span><br><span class="line">            <span class="comment">// 将 pool 放入 usedpool 中</span></span><br><span class="line">            next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            pool-&gt;prevpool = next;</span><br><span class="line">            next-&gt;nextpool = pool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">                <span class="comment">/* Luckily, this pool last contained blocks</span></span><br><span class="line"><span class="comment">                 * of the same size class, so its header</span></span><br><span class="line"><span class="comment">                 * and free list are already initialized.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                bp = pool-&gt;freeblock;</span><br><span class="line">                assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">                pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                    <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Initialize the pool header, set up the free list to</span></span><br><span class="line"><span class="comment">             * contain just the second block, and return the first</span></span><br><span class="line"><span class="comment">             * block.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 初始化pool header，将freeblock指向第二个block，返回第一个block</span></span><br><span class="line">            pool-&gt;szidx = size;</span><br><span class="line">            size = INDEX2SIZE(size);</span><br><span class="line">            bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">            pool-&gt;freeblock = bp + size;</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Carve off a new pool. */</span></span><br><span class="line">        assert(usable_arenas-&gt;nfreepools &gt; <span class="number">0</span>);</span><br><span class="line">        assert(usable_arenas-&gt;freepools == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 从arena中取出一个新的pool</span></span><br><span class="line">        pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">        assert((block*)pool &lt;= (block*)usable_arenas-&gt;address +</span><br><span class="line">                               ARENA_SIZE - POOL_SIZE);</span><br><span class="line">        <span class="comment">// 设置 pool 中的 arenaindex，这个 index 实际上就是 pool 所在的 arena</span></span><br><span class="line">        <span class="comment">// 位于 arenas 所指的数组的序号。用于判断一个 block 是否在某个 pool 中。</span></span><br><span class="line">        pool-&gt;arenaindex = (uint)(usable_arenas - arenas);</span><br><span class="line">        assert(&amp;arenas[pool-&gt;arenaindex] == usable_arenas);</span><br><span class="line">        <span class="comment">// 随后 Python 将新得到的 pool 的 szidx 设置为 0xffff，表示从没管理过 block 集合。</span></span><br><span class="line">        pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">        <span class="comment">// 调整刚获得的 arena 中的 pools 集合，甚至可能调整 usable_arenas</span></span><br><span class="line">        usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">        --usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">            assert(usable_arenas-&gt;nextarena == <span class="literal">NULL</span> ||</span><br><span class="line">                   usable_arenas-&gt;nextarena-&gt;prevarena ==</span><br><span class="line">                   usable_arenas);</span><br><span class="line">            <span class="comment">/* Unlink the arena:  it is completely allocated. */</span></span><br><span class="line">            usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> init_pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The small block allocator ends here. */</span></span><br><span class="line"></span><br><span class="line">redirect:</span><br><span class="line">    <span class="comment">/* Redirect the original request to the underlying (libc) allocator.</span></span><br><span class="line"><span class="comment">     * We jump here on bigger requests, on error in the code above (as a</span></span><br><span class="line"><span class="comment">     * last chance to serve the request) or when the max memory limit</span></span><br><span class="line"><span class="comment">     * has been reached.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span> *result;</span><br><span class="line">        <span class="keyword">if</span> (use_calloc)</span><br><span class="line">            result = PyMem_RawCalloc(nelem, elsize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = PyMem_RawMalloc(nbytes);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            _Py_AllocatedBlocks--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a new arena.  If we run out of memory, return NULL.  Else</span></span><br><span class="line"><span class="comment"> * allocate a new arena, and return the address of an arena_object</span></span><br><span class="line"><span class="comment"> * describing the new arena.  It&#x27;s expected that the caller will set</span></span><br><span class="line"><span class="comment"> * `usable_arenas` to the return value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> arena_object*</span><br><span class="line"><span class="title function_">new_arena</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    <span class="type">void</span> *address;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> debug_stats = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug_stats == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *opt = Py_GETENV(<span class="string">&quot;PYTHONMALLOCSTATS&quot;</span>);</span><br><span class="line">        debug_stats = (opt != <span class="literal">NULL</span> &amp;&amp; *opt != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (debug_stats)</span><br><span class="line">        _PyObject_DebugMallocStats(<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要扩充“未使用的”arena_object列表</span></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="type">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Double the number of arena objects on each allocation.</span></span><br><span class="line"><span class="comment">         * Note that it&#x27;s possible for `numarenas` to overflow.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 确定本次需要申请的arena_object的个数，并申请内存</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">        <span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SIZEOF_SIZE_T &lt;= SIZEOF_INT</span></span><br><span class="line">        <span class="keyword">if</span> (numarenas &gt; SIZE_MAX / <span class="keyword">sizeof</span>(*arenas))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        <span class="comment">// realloc() 对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小</span></span><br><span class="line">        arenaobj = (<span class="keyword">struct</span> arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We might need to fix pointers that were copied.  However,</span></span><br><span class="line"><span class="comment">         * new_arena only gets called when all the pages in the</span></span><br><span class="line"><span class="comment">         * previous arenas are full.  Thus, there are *no* pointers</span></span><br><span class="line"><span class="comment">         * into the old array. Thus, we don&#x27;t have to worry about</span></span><br><span class="line"><span class="comment">         * invalid pointers.  Just to be sure, some asserts:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(usable_arenas == <span class="literal">NULL</span>);</span><br><span class="line">        assert(unused_arena_objects == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the new arenas on the unused_arena_objects list. */</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update globals. */</span></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">    <span class="comment">// 从unused_arena_objects链表中取出一个“未使用的”arena_object</span></span><br><span class="line">    assert(unused_arena_objects != <span class="literal">NULL</span>);</span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 申请arena_object管理的内存</span></span><br><span class="line">    <span class="comment">// 这里的 alloc 对应 linux 下就是 malloc</span></span><br><span class="line">    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* The allocation failed: return NULL after putting the</span></span><br><span class="line"><span class="comment">         * arenaobj back.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = arenaobj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;address = (<span class="type">uintptr_t</span>)address;</span><br><span class="line"></span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">    ++ntimes_arena_allocated;</span><br><span class="line">    <span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">        narenas_highwater = narenas_currently_allocated;</span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* pool_address &lt;- first pool-aligned address in the arena</span></span><br><span class="line"><span class="comment">       nfreepools &lt;- number of whole pools that fit after alignment */</span></span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;</span><br><span class="line">    assert(POOL_SIZE * arenaobj-&gt;nfreepools == ARENA_SIZE);</span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">        --arenaobj-&gt;nfreepools;</span><br><span class="line">        arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>具体可以参考以上注释，以上。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://docs.python.org/2.3/whatsnew/section-pymalloc.html">https://docs.python.org/2.3/whatsnew/section-pymalloc.html</a></p>
<p>《Python 源码解析》</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/01/23/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/01/23/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Python内存管理机制——内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-01-23 16:50:07" itemprop="dateCreated datePublished" datetime="2017-01-23T16:50:07+08:00">2017-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Python 中所有的内存管理机制都有两套实现，这两套实现由编译符号<code>PYMALLOC_DEBUG</code> 控制，当该符号被定义时，使用的是 debug 模式下的内存管理机制，这套机制在正常的内存管理动作之外，还会记录许多关于内存的信息，以方便 Python 在开发时进行调试；而当该符号未被定义时，Python 的内存管理机制只进行正常的内存管理动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /include/Python.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Py_DEBUG) &amp;&amp; defined(WITH_PYMALLOC) &amp;&amp; !defined(PYMALLOC_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PYMALLOC_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h2><p>在 Python 中，内存管理机制被抽象成下图这样的层次似结果。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%883.48.00.png?raw=true" alt="Python 内存管理机制的层次结构"></p>
<h3 id="Layer-0："><a href="#Layer-0：" class="headerlink" title="Layer 0："></a>Layer 0：</h3><p>操作系统提供的内存管理接口，比如 C 运行时所提供的 malloc 和 free 接口。这层由操作系统实现并管理，Python 不能干涉这一层的行为。</p>
<h3 id="Layer-1："><a href="#Layer-1：" class="headerlink" title="Layer 1："></a>Layer 1：</h3><p>Python 基于第 0 层操作系统的内存管理接口包装而成的，这一层并没有在第 0 层加入太多的冻灾，其目的仅仅是为 Python 提供一层同意的 raw memory 的管理接口。防止操作系统的差异。第一次实现就是一组以<code>PyMem_</code>为前缀的函数族。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include/pymem.h</span></span><br><span class="line"></span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(Py_LIMITED_API) || Py_LIMITED_API+0 &gt;= 0x03050000</span></span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Calloc(<span class="type">size_t</span> nelem, <span class="type">size_t</span> elsize);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Realloc(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size);</span><br><span class="line">PyAPI_FUNC(<span class="type">void</span>) PyMem_Free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"><span class="comment">// 这里使用了一个数据结构 PyMemAllocatorEx 里面定义了上下文及四种方法，上面有用 #ifdef...#endif 来初始化该数据结构方法</span></span><br><span class="line"><span class="comment">// 原始 C 语言方法也在该文件中</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">malloc</span>(_PyMem.ctx, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Calloc</span><span class="params">(<span class="type">size_t</span> nelem, <span class="type">size_t</span> elsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (elsize != <span class="number">0</span> &amp;&amp; nelem &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX / elsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">calloc</span>(_PyMem.ctx, nelem, elsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (new_size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">realloc</span>(_PyMem.ctx, ptr, new_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMem_Free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    _PyMem.<span class="built_in">free</span>(_PyMem.ctx, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一层中，Python 还提供了面向 Python 中类型的内存分配器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include/pymem.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Type-oriented memory interface</span></span><br><span class="line"><span class="comment"> * ==============================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate memory for n objects of the given type.  Returns a new pointer</span></span><br><span class="line"><span class="comment"> * or NULL if the request was too large or memory allocation failed.  Use</span></span><br><span class="line"><span class="comment"> * these macros rather than doing the multiplication yourself so that proper</span></span><br><span class="line"><span class="comment"> * overflow checking is always done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_New(type, n) \</span></span><br><span class="line"><span class="meta">  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :	\</span></span><br><span class="line"><span class="meta">	( (type *) PyMem_Malloc((n) * sizeof(type)) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_NEW(type, n) \</span></span><br><span class="line"><span class="meta">  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :	\</span></span><br><span class="line"><span class="meta">	( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The value of (p) is always clobbered by this macro regardless of success.</span></span><br><span class="line"><span class="comment"> * The caller MUST check if (p) is NULL afterwards and deal with the memory</span></span><br><span class="line"><span class="comment"> * error if so.  This means the original value of (p) MUST be saved for the</span></span><br><span class="line"><span class="comment"> * caller&#x27;s memory error handler to not lose track of it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_Resize(p, type, n) \</span></span><br><span class="line"><span class="meta">  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :	\</span></span><br><span class="line"><span class="meta">	(type *) PyMem_Realloc((p), (n) * sizeof(type)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_RESIZE(p, type, n) \</span></span><br><span class="line"><span class="meta">  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :	\</span></span><br><span class="line"><span class="meta">	(type *) PyMem_REALLOC((p), (n) * sizeof(type)) )</span></span><br></pre></td></tr></table></figure>

<p>在 <code>PyMem_New</code> 中，只要提供类型和数量，Python 会自动侦测其所需的内存空间大小。</p>
<h3 id="Layer-2："><a href="#Layer-2：" class="headerlink" title="Layer 2："></a>Layer 2：</h3><p>以 PyObje_为前缀的函数族，主要提供了创建 Python 对象的接口。这一套函数族又被唤作 Pymalloc 机制。</p>
<p>在第二层内存管理机制之上，对于 Python 中的一些常用对象，比如整数对象、字符串对象等，Python 又构建了更高抽象层次的内存管理策略。</p>
<p>真正在 Python 中发挥巨大作用、同时也是 GC 的藏身之处的内存管理机制所在层次。</p>
<h3 id="Layer-3"><a href="#Layer-3" class="headerlink" title="Layer 3:"></a>Layer 3:</h3><p>第三层的内存管理策略，主要就是对象缓冲池机制。（参加书中第一部分，或者下篇博客）。</p>
<h2 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h2><p>在 Python 中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着 Python 在运行期间会大量地执行 malloc 和 free 操作，导致操作系统频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了提高 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。<strong>这也就是之前提到的 Pymalloc 机制</strong>。</p>
<p>在 Python 中，整个小块内存池可以视为一个层次结构，在这个层次结构中，一共分为4层，从下至上分别是：block、pool、arena 和内存池。需要说明的是，block、pool 和 arena 都是 Python 代码中可以找到的实体，而最顶层的『内存池』只是一个概念上的东西，表示 Python 对于整个小块内存分配和释放行为的内存管理机制。</p>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>在最底层，block 是一个确定大小的内存块。在 Python 中，有多种 block，不同种类的 block 都有不同的内存大小，这个内存大小的值被称为 size class。为了在当前主流的平台都能获得最佳性能，所有的 block 的长度都是8字节对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT               8               <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT_SHIFT         3</span></span><br></pre></td></tr></table></figure>

<p>block 上限，当申请的内存大小小于这个上限时，Python 可以使用不同种类的 block 来满足对内存的需求；当神奇的内存大小超过这个上限，Python 就会对内存的请求转交给第一层的内存管理机制，即 PyMem 函数族，来处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_REQUEST_THRESHOLD 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>

<p>现在，需要指出一个相当关键的点，虽然我们这里谈论了很多block，但是在Python中，block只是一个概念，在Python源码中没有与之对应的实体存在。之前我们说对象，对象在Python源码中有对应的PyObject；我们说列表，列表在Python源码中对应PyListObject、PyType_List。这里的block就很奇怪了，它仅仅是概念上的东西，我们知道它是具有一定大小的内存，但它不与Python源码里的某个东西对应。然而，Python却提供了一个管理block的东西，这就是下面要剖析的pool。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>一组 block 的集合称为一个 pool，换句话说，一个 pool 管理着一堆有固定大小的内存块。事实上，pool 管理着一大块内存，它由一定的策略，将这块大的内存划分为多个小的内存块。在 Python 中，一个 pool 的大小通常为一个系统内存页，由于当前大多数 Python 支持的系统的内存页都是4KB，所以 Python 内部也将一个 pool 的大小定义为4KB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Size of the pools used for small blocks. Should be a power of 2,</span></span><br><span class="line"><span class="comment"> * between 1K and SYSTEM_PAGE_SIZE, that is: 1k, 2k, 4k.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When you say memory, my mind reasons in terms of (pointers to) blocks */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* number of allocated blocks    */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* pool&#x27;s free list head         */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* next pool of this size class  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* previous pool       &quot;&quot;        */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* index into arenas of base adr */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* block size class index        */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* bytes to virgin block         */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* largest valid nextoffset      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4KB 中除去 pool_header，还有一大块内存就是 pool 中维护的 block 的集合占用的内存。</p>
<p>前面提到block 是有固定大小的内存块，因此，pool 也携带了大量这样的信息。一个 pool 管理的所有 block，它们的大小都是一样的。也就是说，一个 pool 可能管理了100个32个字节的 block，也可能管理了100个64个字节的 block，但是绝不会有一个管理了50个32字节的 block 和50个64字节的 block 的 pool 存在。每一个 pool 都和一个 size 联系在一起，更确切地说，都和一个 size class index 联系在一起。这就是 <code>pool_header</code> 中的 szindex 的意义。</p>
<p>假设我们手上现在有一块 4KB 的内存，来看看 Python 是如何将这块内存改造为一个管理32字节 block 的 pool，并从 pool 中取出第一块 block 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]-[convert 4k raw memory to pool]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUNDUP(x)    (((x) + ALIGNMENT_MASK) &amp; ~ALIGNMENT_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_OVERHEAD   ROUNDUP(sizeof(struct pool_header))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> struct pool_header* poolp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar block</span></span><br><span class="line"></span><br><span class="line">poolp pool;</span><br><span class="line">block* bp;</span><br><span class="line">…… <span class="comment">// pool指向了一块4kB的内存</span></span><br><span class="line">pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//设置pool的size class index</span></span><br><span class="line">pool-&gt;szidx = size; </span><br><span class="line"><span class="comment">//将size class index转换为size，比如3转换为32字节</span></span><br><span class="line">size = INDEX2SIZE(size); </span><br><span class="line"><span class="comment">//跳过用于pool_header的内存，并进行对齐</span></span><br><span class="line">bp = (block *)pool + POOL_OVERHEAD; </span><br><span class="line"><span class="comment">//实际就是pool-&gt;nextoffset = POOL_OVERHEAD+size+size</span></span><br><span class="line">pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>); </span><br><span class="line">pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">pool-&gt;freeblock = bp + size;</span><br><span class="line">*(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// bp 返回的实际是一个地址，这个地址之后有将近 4KB 的内存实际上都是可用的，但是可用肯定申请内存的函数只会使用[bp, bp+size] 这个区间的内存，这是由 size class index 可用保证的。</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *)bp; </span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%886.54.29.png?raw=true" alt="改造成 pool 后的 4KB 内存"></p>
<p>注意其中的实线箭头是指针，但是虚线箭头不是代表指针，是偏移位置的形象表示。在nextoffset和maxnextoffset中存储的是相对于poo头部的偏移位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]-[allocate block]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">            ++pool-&gt;ref.count;</span><br><span class="line">            bp = pool-&gt;freeblock;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">                <span class="comment">//有足够的block空间</span></span><br><span class="line">                pool-&gt;freeblock = (block *)pool + pool-&gt;nextoffset;</span><br><span class="line">                pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">                <span class="comment">// 设置*freeblock 的动作正是建立离散自由 block 链表的关键所在</span></span><br><span class="line">                *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>原来freeblock指向的是下一个可用的block的起始地址，这一点在上图中也可以看得出。当再次申请32字节的block时，只需返回freeblock指向的地址就可以了，很显然，这时freeblock需要向前进，指向下一个可用的block。这时，nextoffset现身了。</p>
<p>在pool header中，nextoffset和maxoffset是两个用于对pool中的block集合进行迭代的变量：从初始化pool的结果及图16-2中可以看到，它所指示的偏移位置正好指向了freeblock之后的下一个可用的block的地址。从这里分配block的动作也可以看到，在分配了block之后，freeblock和nextoffset都会向前移动一个block的距离，如此反复，就可对所有的block进行一次遍历。而maxnextoffset指名了该pool中最后一个可用的block距pool开始位置的便移，它界定了pool的边界，当nextoffset &gt; maxnextoff 时，也就意味着已经遍历完了pool中所有的block了。</p>
<p>可以想像，一旦Python运转起来，内存的释放动作将会导致pool中出现大量的离散的自由block，Python必须建立一种机制，将这些离散的自由block组织起来，再次使用。这个机制就是所谓的自由block链表。这个链表的关键就着落在pool_header中的那个freeblock身上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="comment">//基于地址P获得离P最近的pool的边界地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_ADDR(P) ((poolp)((uptr)(P) &amp; ~(uptr)POOL_SIZE_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PyObject_Free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="comment">//判断p指向的block是否属于pool</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        <span class="comment">// 被释放的第一个字节的值被设置为当前的 freeblock 的值</span></span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock; </span><br><span class="line">        <span class="comment">// pool 的值被更新，指向其首地址，则一个 block 被插入到了离散自由的 block 链表中</span></span><br><span class="line">        pool-&gt;freeblock = (block *)p;             </span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%887.25.44.png?raw=true" alt="释放了 block 之后产生的自由 block 链表"></p>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>在 Python 中，多个 pool 聚合的结果就是一个 arena。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arena 大小的默认值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_SIZE              (256 &lt;&lt; 10)     <span class="comment">/* 256KB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arena_object 是 arena 的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Record keeping for arenas. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The address of the arena, as returned by malloc.  Note that 0</span></span><br><span class="line"><span class="comment">     * will never be returned by a successful malloc, and is used</span></span><br><span class="line"><span class="comment">     * here to mark an arena_object that doesn&#x27;t correspond to an</span></span><br><span class="line"><span class="comment">     * allocated arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pool-aligned pointer to the next pool to be carved off. */</span></span><br><span class="line">    block* pool_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The number of available pools in the arena:  free pools + never-</span></span><br><span class="line"><span class="comment">     * allocated pools.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uint nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The total number of pools in the arena, whether or not available. */</span></span><br><span class="line">    uint ntotalpools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Singly-linked list of available pools. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whenever this arena_object is not associated with an allocated</span></span><br><span class="line"><span class="comment">     * arena, the nextarena member is used to link all unassociated</span></span><br><span class="line"><span class="comment">     * arena_objects in the singly-linked `unused_arena_objects` list.</span></span><br><span class="line"><span class="comment">     * The prevarena member is unused in this case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * with at least one available pool, both members are used in the</span></span><br><span class="line"><span class="comment">     * doubly-linked `usable_arenas` list, which is maintained in</span></span><br><span class="line"><span class="comment">     * increasing order of `nfreepools` values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Else this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * all of whose pools are in use.  `nextarena` and `prevarena`</span></span><br><span class="line"><span class="comment">     * are both meaningless in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="『未使用』的-arena-和『可用』的-arena"><a href="#『未使用』的-arena-和『可用』的-arena" class="headerlink" title="『未使用』的 arena 和『可用』的 arena"></a>『未使用』的 arena 和『可用』的 arena</h4><p>实际上，在Python中，确实会存在多个arena_object构成的集合，但是这个集合并不构成链表，而是构成了一个arena的数组。数组的首地址由arenas维护，这个数组就是Python中的通用小块内存的内存池；另一方面，nextarea和prevarea也确实是用来连接arena_object组成链表的。</p>
<p>pool_header管理的内存与pool_header自身是一块连续的内存，而areana_object与其管理的内存则是分离的。这后面隐藏着这样一个事实：当pool_header被申请时，它所管理的block集合的内存一定也被申请了；但是当aerna_object被申请时，它所管理的pool集合的内存则没有被申请。换句话说，arena_object和pool集合在某一时刻需要建立联系。注意，这个建立联系的时刻是一个关键的时刻，Python从这个时刻一刀切下，将一个arena_object切分为两种状态。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%887.49.39.png?raw=true" alt="pool 和 arena 的内存布局区别"></p>
<p>当一个arena的area_object没有与pool集合建立联系时，这时的arena处于“未使用”状态；一旦建立了联系，这时arena就转换到了“可用”状态。对于每一种状态，都有一个arena的链表。“未使用”的arena的链表表头是unused_arena_objects、arena与arena之间通过nextarena连接，是一个单向链表；而“可用”的arena的链表表头是usable_arenas、arena与arena之间通过nextarena和prevarena连接，是一个双向链表。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%887.56.39.png?raw=true" alt="某一时刻多个 arena 的一个可能状态"></p>
<h4 id="申请-arena"><a href="#申请-arena" class="headerlink" title="申请 arena"></a>申请 arena</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arenas管理着arena_object的集合</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//当前arenas中管理的arena_object的个数</span></span><br><span class="line"><span class="type">static</span> uint maxarenas = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//“未使用的”arena_object链表</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//“可用的”arena_object链表</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//初始化时需要申请的arena_object的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_ARENA_OBJECTS 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> arena_object* <span class="title function_">new_arena</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span> </span><br><span class="line">    uint excess;  <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//[1]: 判断是否需要扩充“未使用的”arena_object列表</span></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123; <span class="comment">// if one</span></span><br><span class="line">    uint i;</span><br><span class="line">    uint numarenas;</span><br><span class="line">    <span class="type">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]: 确定本次需要申请的arena_object的个数，并申请内存</span></span><br><span class="line">    numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">    <span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//overflow（溢出）</span></span><br><span class="line">    nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">    <span class="keyword">if</span> (nbytes / <span class="keyword">sizeof</span>(*arenas) != numarenas)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//overflow</span></span><br><span class="line">    arenaobj = (<span class="keyword">struct</span> arena_object *)<span class="built_in">realloc</span>(arenas, nbytes);</span><br><span class="line">    <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[3]: 初始化新申请的arena_object，并将其放入unused_arena_objects链表中</span></span><br><span class="line">    <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">      arenas[i].address = <span class="number">0</span>;  <span class="comment">/* mark as unassociated */</span></span><br><span class="line">      arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ? &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Update globals. */</span></span><br><span class="line">    unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">    maxarenas = numarenas;</span><br><span class="line">&#125; <span class="comment">// end one</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//[4]: 从unused_arena_objects链表中取出一个“未使用的”arena_object</span></span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//[5]: 申请arena_object管理的内存</span></span><br><span class="line">    arenaobj-&gt;address = (uptr)<span class="built_in">malloc</span>(ARENA_SIZE);</span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//[6]: 设置pool集合的相关信息</span></span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;</span><br><span class="line">    <span class="comment">//将pool的起始地址调整为系统页的边界</span></span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">    --arenaobj-&gt;nfreepools;</span><br><span class="line">    arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">   &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><h4 id="可用-pool-缓冲池——usedpools"><a href="#可用-pool-缓冲池——usedpools" class="headerlink" title="可用 pool 缓冲池——usedpools"></a>可用 pool 缓冲池——usedpools</h4><p>Python 内部默认的小块内存与大块内存的分界点定在512个字节，这个分界点由前面我们看到的名为<code>SMALL_REQUEST_THRESHOLD</code> 的符号控制。也就是说，当申请的内存小于512字节时，<code>PyObject_Malloc</code> 会在内存池中申请内存；当申请的内存大于512字节时，<code>PyObject_Malloc</code> 的行为将退化为 malloc 的行为。</p>
<p>在Python中，pool是一个有size概念的内存管理抽象体，一个pool中的block总是有确定的大小，这个pool总是和某个size class index对应，还记得pool_head中的那个szidx么？而arena是没有size概念的内存管理抽象体，这就意味着，同一个arena，在某个时刻，其内的pool集合可能都是管理的32字节的block；而到了另一时刻，由于系统需要，这个arena可能被重新划分，其中的pool集合可能改为管理64字节的block了，甚至pool集合中一半管理32字节，一半管理64字节。这就决定了在进行内存分配和销毁时，所有的动作都是在pool上完成的。</p>
<p>内存池中的pool，不仅是一个有size概念的内存管理抽象体，而且，更进一步的，它还是一个有状态的内存管理抽象体。一个pool在Python运行的任何一个时刻，总是处于以下三种状态的一种：</p>
<ul>
<li>used状态：pool中至少有一个block已经被使用，并且至少有一个block还未被使用。这种状态的pool受控于Python内部维护的usedpools数组；</li>
<li>full状态：pool中所有的block都已经被使用，这种状态的pool在arena中，但不在arena的freepools链表中；</li>
<li>empty状态：pool中所有的block都未被使用，处于这个状态的pool的集合通过其pool_header中的nextpool构成一个链表，这个链表的表头就是arena_object中的freepools；</li>
</ul>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.25.34.png?raw=true" alt="某个时刻 aerna 中 pool 集合的可能状态"></p>
<p>Python内部维护的usedpools数组是一个非常巧妙的实现，维护着所有的处于used状态的pool。当申请内存时，Python就会通过usedpools寻找到一块可用的（处于used状态的）pool，从中分配一个block。一定有一个与usedpools相关联的机制，完成从申请的内存的大小到size class index之间的转换，否则Python也就无法寻找到最合适的pool了。这种机制与usedpools的结构有密切的关系，我们来看一看usedpools的结构。</p>
<p>一定有一个与usedpools相关联的机制，完成从申请的内存的大小到size class index之间的转换，否则Python也就无法寻找到最合适的pool了。这种机制与usedpools的结构有密切的关系，我们来看一看usedpools的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uchar block;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTA(x)  ((poolp )((uchar *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT(x)   PTA(x), PTA(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 poolp 指的就是 pool_head</span></span><br><span class="line"><span class="type">static</span> poolp usedpools[<span class="number">2</span> * ((NB_SMALL_SIZE_CLASSES + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 8 <span class="comment">//指明了在当前的配置之下，一共有多少个 size class</span></span></span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line">    …… </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>其中的<code>NB_SMALL_SIZE_CLASSES</code>指明了在当前的配置之下，一共有多少个size class。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.29.02.png?raw=true" alt="usedpools 数组"></p>
<p>Python会首先获得 size class index，通过 size &#x3D; (uint )(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT，得到 size class index 为3。在usedpools 中，寻找第3+3&#x3D;6个元素，发现 usedpools[6] 的值是指向 usedpools[4] 的地址。有些迷惑了，对吧？好了，现在对照 pool_header 的定义来看一看 usedpools[6] -&gt; nextpool 这个指针指向哪里了呢？是从 usedpools[6]（即usedpools+4）开始向后偏移8个字节（一个ref的大小加上一个freeblock的大小）后的内存，不正是 usedpools[6] 的地址（即usedpools+6）吗？这是Python内部使用的一个 trick。</p>
<p>想象一下，当我们手中有一个size class为32字节的pool，想要将其放入这个usedpools中时，需要怎么做呢？从上面的描述可以看到，只需要进行usedpools[i+i]-&gt;nextpool &#x3D; pool即可，其中i为size class index，对应于32字节，这个i为3。当下次需要访问size class为32字节（size class index为3）的pool时，只需要简单地访问usedpool[3+3]就可以得到了。Python正是使用这个usedpools快速地从众多的pool中快速地寻找到一个最适合当前内存需求的pool，从中分配一块block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">PyObject_Malloc</span><span class="params">(<span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">        LOCK();</span><br><span class="line">        <span class="comment">//获得size class index</span></span><br><span class="line">        size = (uint )(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">        pool = usedpools[size + size];</span><br><span class="line">        <span class="comment">//usedpools中有可用的pool</span></span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">            ……<span class="comment">//usedpools中有可用的pool</span></span><br><span class="line">        &#125;</span><br><span class="line">        …… <span class="comment">//usedpools中无可用pool，尝试获取empty状态pool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Pool-的初始化"><a href="#Pool-的初始化" class="headerlink" title="Pool 的初始化"></a>Pool 的初始化</h4><p>当 Python 启动之后，在 usedpools 这个小块空间内存池中，并不存在任何可用的内存，准确地说，不存在任何可用的pool。在这里，Python 采用了延迟分配的策略，即当我们确实开始申请小块内存时，Python 才开始建立这个内存池。</p>
<p>考虑一下这样的情况，当申请32字节内存时，从“可用的” arena 中取出其中一个 pool 用作32字节的 pool 。当下一次内存分配请求分配64字节的内存时，Python 可以直接使用当前“可用的” arena 的另一个 pool 即可。这正如我们前面所说， arena 没有 size class 的属性，而 pool 才有（见下面代码）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">PyObject_Malloc</span><span class="params">(<span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    block *bp; </span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">    LOCK();</span><br><span class="line">    size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">    pool = usedpools[size + size];</span><br><span class="line">    <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">      …… <span class="comment">//usedpools中有可用的pool</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//usedpools中无可用pool，尝试获取empty状态pool</span></span><br><span class="line">    <span class="comment">//[1]: 如果usable_arenas链表为空，则创建链表</span></span><br><span class="line">    <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//申请新的arena_object，并放入usable_arenas链表</span></span><br><span class="line">      usable_arenas = new_arena();</span><br><span class="line">      usable_arenas-&gt;nextarena = usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]: 从usable_arenas链表中第一个arena的freepools中抽取一个可用的pool</span></span><br><span class="line">    pool = usable_arenas-&gt;freepools;</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line">      <span class="comment">//[3]: 调整usable_arenas链表中第一个arena中的可用pool数量</span></span><br><span class="line">      <span class="comment">//如果调整后数量为0，则将该arena从usable_arenas链表中摘除</span></span><br><span class="line">      --usable_arenas-&gt;nfreepools;</span><br><span class="line">      <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">        usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">        <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    init pool:</span><br><span class="line">            ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化之一"><a href="#初始化之一" class="headerlink" title="初始化之一"></a>初始化之一</h5><p>好了，现在我们手里有了一块用于32字节内存分配的pool，为了以后提高内存分配的效率，我们需要将这个pool放入到usedpools中。这一步，叫做init pool。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUNDUP(x)    (((x) + ALIGNMENT_MASK) &amp; ~ALIGNMENT_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_OVERHEAD   ROUNDUP(sizeof(struct pool_header))</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">PyObject_Malloc</span><span class="params">(<span class="type">size_t</span> nbytes)</span> &#123;</span><br><span class="line">……</span><br><span class="line">init_pool:</span><br><span class="line">            <span class="comment">//[1]: 将pool放入usedpools中</span></span><br><span class="line">            next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            pool-&gt;prevpool = next;</span><br><span class="line">            next-&gt;nextpool = pool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//[2]：pool在之前就具有正确的size结构，直接返回pool中的一个block</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">                bp = pool-&gt;freeblock;</span><br><span class="line">                pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//[3]： 初始化pool header，将freeblock指向第二个block，返回第一个block</span></span><br><span class="line">            pool-&gt;szidx = size;</span><br><span class="line">            size = INDEX2SIZE(size);</span><br><span class="line">            bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">            pool-&gt;freeblock = bp + size;</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在什么样的情况下才会发生一个 pool 从 empty 状态转换为 used 状态呢？假设申请的内存的 size class index 为 i，且 usedpools[i+i] 处没有处于 used 状态的 pool ，同时在 Python 维护的全局变量 freepools 中还有处于 empty 的 pool ，那么位于 freepools 所维护的 pool 链表头部的 pool 将被取出来，放入 usedpools 中，并从其内部分配一块 block 。同时，这个 pool 也就从 empty 状态转换到了 used 状态。下面我们看一看这个行为在代码中是如何体现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line">    ……</span><br><span class="line">        pool = usable_arenas-&gt;freepools;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line">            …… <span class="comment">//调整usable_arenas-&gt;nfreepools和usable_arenas自身</span></span><br><span class="line">            [init_pool] </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h5 id="初始化之二"><a href="#初始化之二" class="headerlink" title="初始化之二"></a>初始化之二</h5><p>我们现在可以来看看，当PyObject_Malloc从new_arena中得到一个新的arena后，是怎么样来初始化其中的pool集合，并最终完成PyObject_Malloc函数的分配一个block这个终极任务的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUMMY_SIZE_IDX    0xffff  <span class="comment">/* size class of newly cached pools */</span></span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">PyObject_Malloc</span><span class="params">(<span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    block *bp; </span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//[1]：从arena中取出一个新的pool</span></span><br><span class="line">    pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">    <span class="comment">// 设置 pool 中的 arenaindex，这个 index 实际上就是 pool 所在的 arena 位于 arenas 所指的数组的序号。用于判断一个 block 是否在某个 pool 中。</span></span><br><span class="line">    pool-&gt;arenaindex = usable_arenas - arenas;</span><br><span class="line">    <span class="comment">// 随后 Python 将新得到的 pool 的 szidx 设置为 0xffff，表示从没管理过 block 集合。</span></span><br><span class="line">    pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">    <span class="comment">// 调整刚获得的 arena 中的 pools 集合，甚至可能调整 usable_arenas</span></span><br><span class="line">    usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">    --usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Unlink the arena:  it is completely allocated. */</span></span><br><span class="line">    usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">    <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> init_pool;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="block-的释放"><a href="#block-的释放" class="headerlink" title="block 的释放"></a>block 的释放</h4><p>pool 的状态变更最为常见的还是之前是 used 之后也是 used：</p>
<p>在pool的状态保持used状态这种情况下，Python仅仅将block重新放入到自由block链表中，并调整了pool中的ref.count这个引用计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PyObject_Free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        <span class="comment">//设置离散自由block链表</span></span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">        pool-&gt;freeblock = (block *)p;</span><br><span class="line">        <span class="keyword">if</span> (lastfree) &#123; <span class="comment">//lastfree有效，表明当前pool不是处于full状态</span></span><br><span class="line">             <span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123; <span class="comment">//pool不需要转换为empty状态</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//待释放的内存在PyObject_Malloc中是通过malloc获得的</span></span><br><span class="line">    <span class="comment">//所以要归还给系统</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们释放一个 block 后，可能会引起 pool 的状态的转变，这种转变可分为两种情况：</p>
<ul>
<li><p>full状态转变为used状态</p>
<p> 仅仅是将 pool 重新链回到 usedpools 中即可</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="type">void</span> <span class="title function_">PyObject_Free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">//当前pool处于full状态，在释放一块block后，需将其转换为used状态，并重新</span></span><br><span class="line">        <span class="comment">//链入usedpools的头部</span></span><br><span class="line">        --pool-&gt;ref.count;</span><br><span class="line">        size = pool-&gt;szidx;</span><br><span class="line">        next = usedpools[size + size];</span><br><span class="line">        prev = next-&gt;prevpool;</span><br><span class="line">        <span class="comment">/* insert pool before next:   prev &lt;-&gt; pool &lt;-&gt; next */</span></span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        pool-&gt;prevpool = prev;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        prev-&gt;nextpool = pool;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>used状态转变为empty状态</p>
<p> 首先 Python 要做的是将empty状态的 pool 链入到 freepools 中去</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PyObject_Free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">        pool-&gt;freeblock = (block *)p;</span><br><span class="line">        <span class="keyword">if</span> (lastfree) &#123; </span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">ao</span>;</span> </span><br><span class="line">             uint nf;  <span class="comment">//ao-&gt;nfreepools </span></span><br><span class="line">             <span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将pool放入freepools维护的链表中</span></span><br><span class="line">            <span class="comment">// 这里隐藏着一个类似于内存泄露的问题：arena 从来不释放 pool</span></span><br><span class="line">            ao = &amp;arenas[pool-&gt;arenaindex];</span><br><span class="line">            pool-&gt;nextpool = ao-&gt;freepools;</span><br><span class="line">            ao-&gt;freepools = pool;</span><br><span class="line">            nf = ++ao-&gt;nfreepools;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 现在开始处理 arena，分为四种情况：</p>
<ul>
<li><p>如果arena中所有的pool都是empty的，释放pool集合占用的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PyObject_Free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">ao</span>;</span>  </span><br><span class="line">    uint nf;  <span class="comment">//ao-&gt;nfreepools </span></span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//将pool放入freepools维护的链表中</span></span><br><span class="line">    ao = &amp;arenas[pool-&gt;arenaindex];</span><br><span class="line">    pool-&gt;nextpool = ao-&gt;freepools;</span><br><span class="line">    ao-&gt;freepools = pool;</span><br><span class="line">    nf = ++ao-&gt;nfreepools;</span><br><span class="line">    <span class="keyword">if</span> (nf == ao-&gt;ntotalpools) &#123;</span><br><span class="line">        <span class="comment">//调整usable_arenas链表</span></span><br><span class="line">        <span class="keyword">if</span> (ao-&gt;prevarena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            usable_arenas = ao-&gt;nextarena;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ao-&gt;prevarena-&gt;nextarena = ao-&gt;nextarena;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (ao-&gt;nextarena != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ao-&gt;nextarena-&gt;prevarena = ao-&gt;prevarena;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调整unused_arena_objects链表</span></span><br><span class="line">        ao-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = ao;</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">free</span>((<span class="type">void</span> *)ao-&gt;address);</span><br><span class="line">        <span class="comment">//设置address，将arena的状态转为“未使用”</span></span><br><span class="line">        ao-&gt;address = <span class="number">0</span>;</span><br><span class="line">        --narenas_currently_allocated;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果之前arena中没有了empty的pool，那么在usable_arenas链表中就找不到该arena，由于现在arena中有了一个pool，所以需要将这个aerna链入到usable_arenas链表的表头。</p>
</li>
<li><p>若arena中的empty的pool个数为n，则从usable_arenas开始寻找arena可以插入的位置，将arena插入到usable_arenas。这个操作的原因是由于usable_arenas实际上是一个有序的链表，从表头开始往后，每一个arena中的empty的pool的个数，即nfreepools，都不能大于前面的arena，也不能小于前面的arena。保持这种有序性的原因是分配block时，是从usable_arenas的表头开始寻找可用的arena的，这样，就能保证如果一个arena的empty pool数量越多，它被使用的机会就越少。因此，它最终释放其维护的pool集合的内存的机会就越大，这样就能保证多余的内存会被归还给系统。</p>
</li>
<li><p>其他情况，不进行任何对arena的处理。</p>
</li>
</ul>
<p> ​</p>
</li>
</ul>
<h4 id="内存池全景"><a href="#内存池全景" class="headerlink" title="内存池全景"></a>内存池全景</h4><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%889.59.26.png?raw=true" alt="Python 的小块内存的内存池全景"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Python 源码解析》</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/10/01/openresty%E5%88%9D%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/10/01/openresty%E5%88%9D%E5%AD%A6/" class="post-title-link" itemprop="url">openresty初学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-10-01 16:27:20" itemprop="dateCreated datePublished" datetime="2016-10-01T16:27:20+08:00">2016-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间由于不想将一些团队必须有的业务逻辑（如封禁IP，各种常规检查，转发等）写于各个业务线上，于是我们就动起了使用<code>lua</code>在 <code>nginx</code>做手脚的心思，一开始本来就组长一个人在弄，后面我出于好奇，就『自愿』援助了其中一条业务线的一个适合写在<code>nginx</code>的功能，这个功能具体不加以描述，总体来说涉及到了过滤请求，查询数据库，分发请求这几个步骤。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/10/01/openresty%E5%88%9D%E5%AD%A6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/21/Redis%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/04/21/Redis%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">Redis与消息队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-04-21 16:19:11" itemprop="dateCreated datePublished" datetime="2016-04-21T16:19:11+08:00">2016-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub&#x2F;Sub"></a>Pub&#x2F;Sub</h3><p>Redis中使用<a target="_blank" rel="noopener" href="http://redis.io/commands/subscribe">SUBSCRIBE</a>, <a target="_blank" rel="noopener" href="http://redis.io/commands/unsubscribe">UNSUBSCRIBE</a> 和 <a target="_blank" rel="noopener" href="http://redis.io/commands/publish">PUBLISH</a> 方法将可以实现生产者&#x2F;消费者模式，所谓的生产者其实就是使用<code>PUBLISH</code>将message(这里需要说明，message只能是String，不过我们可以序列化一个对象为Json再进行推送)推送到指定的队列中，再由<code>SUBSCRIBE</code>监听到消息并取出。<code>UNSUBSCRIBE</code>是取消监听。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/04/21/Redis%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/03/24/%E5%88%9D%E5%AD%A6Kafka%E2%80%94%E2%80%94Kafka%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/03/24/%E5%88%9D%E5%AD%A6Kafka%E2%80%94%E2%80%94Kafka%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">初学Kafka——Kafka配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-03-24 16:22:24" itemprop="dateCreated datePublished" datetime="2016-03-24T16:22:24+08:00">2016-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>我使用的是vagrant配置的Debian8环境</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/03/24/%E5%88%9D%E5%AD%A6Kafka%E2%80%94%E2%80%94Kafka%E9%85%8D%E7%BD%AE/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/03/22/%E5%88%9D%E5%AD%A6Kafka%E2%80%94%E2%80%94Kafka%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%85%B6%E8%AE%B2%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/03/22/%E5%88%9D%E5%AD%A6Kafka%E2%80%94%E2%80%94Kafka%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%85%B6%E8%AE%B2%E8%A7%A3/" class="post-title-link" itemprop="url">初学Kafka——Kafka实例及其讲解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-03-22 16:21:45" itemprop="dateCreated datePublished" datetime="2016-03-22T16:21:45+08:00">2016-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>Topic：</strong>Kafka将消息种子(Feed)分门别类， 每一类的消息称之为话题(Topic).<br><strong>Producer：</strong>发布消息的对象称之为话题生产者(Kafka topic producer)<br><strong>Consumer：</strong>订阅消息并处理发布的消息的种子的对象称之为话题消费者(consumers)<br><strong>Broker：</strong>已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个话题，并从Broker拉数据，从而消费这些已发布的消息。<br><strong>Partition：</strong>每个Topic下会有一个或多个Partition，创建Topic时可指定Parition数量。每个Partition对应于一个文件夹，该文件夹下存储该{Partition的数据和索引文件。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/03/22/%E5%88%9D%E5%AD%A6Kafka%E2%80%94%E2%80%94Kafka%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%85%B6%E8%AE%B2%E8%A7%A3/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/03/11/MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/03/11/MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/" class="post-title-link" itemprop="url">MySQL优化概要</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-03-11 16:18:14" itemprop="dateCreated datePublished" datetime="2016-03-11T16:18:14+08:00">2016-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-23 12:03:46" itemprop="dateModified" datetime="2023-12-23T12:03:46+08:00">2023-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先我们需要明确我们什么时候需要用到数据库：</p>
<ol>
<li>当缓存并不能解决你的问题，比如写操作，事务操作</li>
<li>缓存的创建或过期需要通过数据库。</li>
</ol>
<p>其次，我们可能需要一个专业的工具来指导我们优化：<br><code>mysqlreport</code><br>这是作为一个Mysql第三方的状态报告工具，其实就是将一下两行命令所获得的数据以一种更加人性化的方法呈现到我们眼前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status;</span><br><span class="line">mysql&gt; show engine innodb status; </span><br></pre></td></tr></table></figure>

<p>你完全可以在自己电脑上先使用这个工具，这时候我们将逐条讲解工具为我们呈现的数据</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/03/11/MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘冰鉴</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
