---
title: Java 内存模型与线程
date: 2017-12-02 23:28:58
tags:
    - JVM
    - Java
categories: 基础原理
---

## 预热

所谓并发的时代，其实不仅仅提现在并发友好的库、框架、语言在兴起，而是这种并发的思想，早已融入到计算机最底层中了。

『让计算机并发执行若干个运算任务』与『更充分地利用计算机处理器的效能』之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的**运算任务都不可能只靠处理器『计算』就能完成**，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。

由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不**加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲**：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当**运算结束后再从缓存同步回内存之中**，这样处理器就无须等待缓慢的内存读写了。

嫌上面文字太长了，**简单说来**就是：计算机计算太快了，等不及慢的主存了，加了 L3、L2、L1 以及寄存器4个高速缓存就是为了让 IO 能快点。

由此产生出了一个问题

<!-- more -->

### 缓存一致性

在多处理器系统中，每个处理器**都有自己的高速缓存**，而**它们又共享同一主内存**（Main Memory），如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及DragonProtocol等。

### 什么是内存模型

内存模型可以理解为**在特定的操作协议（上述协议）下，对特定的内存或高速缓存进行读写访问的过程抽象**。

不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。

![处理器、高速缓存、主内存间的交互关系](https://github.com/BingLau7/blog/blob/master/images/blog_39/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E5%99%A8%E4%BA%A4%E4%BA%92.png?raw=true)

### 重排序

除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。

与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。

>  对处理器的重排序感兴趣的同学可以去看看《深入理解计算机系统》的第 4 章 处理器体系架构



## Java 内存模型

之所以有 Java 内存模型（Java Memory Model，JMM）存在的意义是为了屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

### 主内存与工作内存

Java 内存模型的**主要目标是定义程序中各个变量的访问规则**，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它**包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数**，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，**Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。**

![线程、主内存、工作内存三者的交互关系](https://github.com/BingLau7/blog/blob/master/images/blog_39/Java%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92.png?raw=true)

Java 内存模型规定了**所有的变量都存储在主内存**（MainMemory）中（非系统主内存，虚拟机内存一部分）。**每条线程还有自己的工作内存**（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，**线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行**，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量值的传递均需要通过主内存来完成**，线程、主内存、工作内存三者的交互关系如图所示。

### 内存见交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，**虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的**（对于 double 和 long 类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。

-  lock（锁定）：作用于主内存的变量，它**把一个变量标识为一条线程独占的状态**。   
-  unlock（解锁）：作用于主内存的变量，它**把一个处于锁定状态的变量释放出来**，释放后的变量才可以被其他线程锁定。   
-  read（读取）：作用于主内存的变量，它**把一个变量的值从主内存传输到线程的工作内存中**，以便随后的load动作使用。   
-  load（载入）：作用于工作内存的变量，它**把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。**   
-  use（使用）：作用于工作内存的变量，它**把工作内存中一个变量的值传递给执行引擎**，**每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。**   
-  assign（赋值）：作用于工作内存的变量，它**把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。**   
-  store（存储）：作用于工作内存的变量，它**把工作内存中一个变量的值传送到主内存中**，以便随后的write操作使用。   
-  write（写入）：作用于主内存的变量，它**把store操作从工作内存中得到的变量的值放入主内存的变量中**。

略解释一下以上的操作：

-  把一个变量从主内存复制到工作内存： 顺序执行 read、 load
-  把一个变量从工作内存同步回主内存：顺序执行 store、 write

注意**『顺序执行』不代表是连续执行**。

除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则：

-  不允许 read 和 load、store 和 write 操作之一单独出现，即**不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现**。
-  不允许一个线程丢弃它的最近的 assign 操作，即**变量在工作内存中改变了之后必须把该变化同步回主内存**。
-  **不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中**。
-  **一个新的变量只能在主内存中『诞生』**，不允许在工作内存中直接使用一个未被初始化（ load 或 assign ）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。
-  一**个变量在同一个时刻只允许一条线程对其进行 lock 操作**，但 lock 操作可以被同一条线程重复执行多次，**多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁**。   
-  **如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。**   
-  **如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。**   
-  **对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中**（执行 store、write 操作）。

### volatile

当一个变量定义为 volatile 之后，它将具备两种特性

#### 可见性

保证此变量对所有线程的**可见性**，这里的『可见性』是**指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的**。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。

可见性常被误解，认为以下描述成立：『volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的』。这句话的论据部分并没有错，但是**其论据并不能得出『基于volatile变量的运算在并发下是安全的』**。

**volatile 变量在各个线程的工作内存中不存在一致性问题**（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。我们可以看看下面这个实例。

```java
public class VolatileTest {
    public static volatile int race = 0;

    public static void increaes() {
        race++;
    }

    private static final int THREADES_COUNT = 20;

    public static void main(String[] args) {
        Thread[] threads = new Thread[THREADES_COUNT];
        for (int i = 0; i <THREADES_COUNT; i++) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 10000; j++) {
                        increaes();
                    }
                }
            });
            threads[i].start();
        }

        // 等待所有累加线程都结束
        while (Thread.activeCount() > 1) {
            Thread.yield();
        }

        System.out.println(race);
    }
}
```

这段代码发起了 20 个线程，每个对 race 进行了 10000 次自增操作，如果这段代码正确运行的话，结果应该是 200000 ，但总是会事与愿违。

>  这儿有一点特别奇怪，我在 idea 上面运行上述代码发现一直不能停止，后面试了试 Thread.activeCount() 的值，发现我这边不开启任何子线程数值都是 2。然后将当前线程组打印出来。
>
>  ```java
>  	    System.out.println(Thread.activeCount());
>          ThreadGroup group = Thread.currentThread().getThreadGroup();
>          group.list();
>  ```
>
>  结果如下
>
>  ```
>  2
>  java.lang.ThreadGroup[name=main,maxpri=10]
>      Thread[main,5,main]
>      Thread[Monitor Ctrl-Break,5,main]
>  ```
>
>  然后根据去 Monitor Ctrl-Break 查资料发现
>
>  java 实际开始运行的类是com.intellij.rt.execution.application.AppMain。AppMain 通过反射调用我们写的类，还会创建另一个名叫 Monitor Ctrl-Break 的线程，从名字看应该是监控 Ctrl-Break 中断信号的。
>
>  https://www.zhihu.com/question/59297272
>
>  还蛮有趣的

问题就出现在自增运算『race++』之中，我们用 Javap 反编译这段代码后会得到下面的代码，发现只有一行代码的`increase()` 方法在 Class 文件中是由4条字节码指令构成的（return 指令不是由 race++ 产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当 getstatic 指令把 race 的值取到操作栈顶时，volatile 关键字保证了 race 的值在此时是正确的，但是在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 race 值同步回主内存之中。

```java
  public static void increaes();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=0, args_size=0
         0: getstatic     #2                  // Field race:I
         3: iconst_1
         4: iadd
         5: putstatic     #2                  // Field race:I
         8: return
      LineNumberTable:
        line 11: 0
        line 12: 8
```

客观来说这样也不严谨，因为字节码的一个指令也并不意味这是一个院子操作。

由于volatile变量只能保证可见性，在**不符合以下两条规则的运算场景中，我们仍然要通过加锁**（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。

-  运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
-  变量不需要与其他的状态变量共同参与不变约束。

#### 禁止指令重排序优化

>  可查看文章开头的 **volatile变量法则**

使用 volatile 变量的第二个语义是**禁止指令重排序优化**，**普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致**。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。

上述有些不太好理解，那么我们就看实例吧

```java
Map configOptions;
char[] configText;
// 此变量必须定义为 volatile
volatile boolean initialized = false;

// 假设以下代码在线程 A 中执行
// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用
configOptions = new HashMap();
configText = readConfigFile(fileName);
processConfigOptions(configText, configOptions);
initialized = true;

// 假设以下代码在线程B中执行
// 等待initialized为true，代表线程A已经把配置信息初始化完成
while (!initialized) {
  sleep();
}

// 使用线程A中初始化好的配置信息
doSomethingWithConfig();
```

如果定义 initialized 变量时没有使用 volatile 修饰，就可能会由于指令重排序的优化，**导致位于线程 A 中最后一句的代码`initialized=true` 被提前执行**（这里虽然使用 Java 作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程 B 中使用配置信息的代码就可能出现错误，而 volatile 关键字则可以避免此类情况的发生。

下面这个例子说明一下 **volatile 关键字是如何禁止指令重排序优化**的。下面是一段标准的 DCL 单例代码，可观察加入 volatile 和未加入 volatile 关键字时所生成汇编代码的差别。(使用 HSDIS )（我们就通过行数找）

加入前：

```
  0x00000001086f3207: movabs $0x107ba5abe,%r10
  0x00000001086f3211: callq  *%r10              ;*monitorexit
                                                ; - VolatileSingleton::getInstance@28 (line 14)

  0x00000001086f3214: jmpq   0x00000001086f2fe6  ;*new
                                                ; - VolatileSingleton::getInstance@17 (line 12)

  0x00000001086f3219: mov    %rax,%rbx
  0x00000001086f321c: jmp    0x00000001086f3221  ;*invokespecial <init>
                                                ; - VolatileSingleton::getInstance@21 (line 12)

  0x00000001086f321e: mov    %rax,%rbx

```

加入后：

```
  0x000000010eff4100: mov    (%rsp),%r10
  0x000000010eff4104: shr    $0x3,%r10
  0x000000010eff4108: movabs $0x76ab81e48,%r11  ;   {oop(a 'java/lang/Class' = 'VolatileSingleton')}
  0x000000010eff4112: mov    %r10d,0x68(%r11)
  0x000000010eff4116: movabs $0x76ab81e48,%r10  ;   {oop(a 'java/lang/Class' = 'VolatileSingleton')}
  0x000000010eff4120: shr    $0x9,%r10
  0x000000010eff4124: movabs $0x1038b7000,%r11
  0x000000010eff412e: mov    %r12b,(%r11,%r10,1)
  0x000000010eff4132: lock addl $0x0,(%rsp)     ;*putstatic instance
                                                ; - VolatileSingleton::getInstance@24 (line 12)
```

虽然看不是很懂，但是还是很明显有一个重排序的区别以及 `lock addl $0x0,(%rsp)` 这个操作在赋值后（`mov    (%rsp),%r10`）的区别。

这个操作相当于一个**内存屏障**（Memory Barrier 或 Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个 CPU 访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。

>  内存屏障
>
>  内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。
>  内存屏障可以被分为以下几种类型
>
>  -  LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
>  -  StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
>  -  LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
>  -  StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
>
>  有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。
>
>  ![内存屏障](https://github.com/BingLau7/blog/blob/master/images/blog_39/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png?raw=true)

在某些情况下，volatile 的同步机制的性能确实要优于锁（使用 synchronized 关键字或 java.util.concurrent 包里面的锁），但是由于**虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为 volatile 就会比 synchronized 快多少**。如果让volatile自己与自己比较，那可以确定一个原则：**volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些**，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下 volatile 的总开销仍然要比锁低，我**们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求**。

#### JOJO，这是我最后的实例了

最后，我们回顾一下 Java 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 型变量，那么在进行 read、load、use、assign、store 和 write 操作时需要满足如下规则：

-  只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。（**线程中 use 在 load 之后，只有后面出现 use 才能出现 load，use 可以理解与 load、read 必须一起连续出现**）。
-  只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。（**线程中 store 在 assign 之后，只有后面出现 store 才能出现 assign，assign 可以理解与 store、write 必须一起连续出现**）
-  假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或as-sign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。

### 对于 long 和 double 变量的特殊规则

Java内存模型要求 lock、unlock、read、load、assign、use、store、write 这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的 load、store、read 和 write 这4个操作的原子性，这点就是所谓的 **long 和 double 的非原子性协定**（Nonatomic Treatment ofdouble and long Variables）。

Java 内存模型虽然允许虚拟机不把 long 和 double 变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还『强烈建议』虚拟机这样实现。在实际开发中，目前**各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待**，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。

### 原子性，可见性与有序性

**Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的**，我们逐个来看一下哪些操作实现了这 3 个特性。

#### 原子性

由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的。

如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却**提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性**。

#### 可见性

可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是**通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的**，无论是普通变量还是volatile变量都是如此，普通变量与 volatile 变量的区别是，**volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新**。因此，可以说 **volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点**。

除了 volatile 之外，Java 还有两个关键字能实现可见性

-  synchronized。同步块的可见性是由『对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）』这条规则获得的
-  final。被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把『this』的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到『初始化了一半』的对象），那在其他线程中就能看见 final 字段的值。

#### 有序性

Java程序中天然的有序性可以总结为一句话：**如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。**

前半句是指“线程内表现为串行的语义”（Within-Thread As-If-SerialSemantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

**Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性**，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由『一个变量在同一个时刻只允许一条线程对其进行lock操作』这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

>  介绍完并发中 3 种重要的特性后，读者有没有发现 synchronized 关键字在需要这 3 种特性的时候都可以作为其中一种的解决方案？看起来很『万能』吧。的确，大部分的并发控制操作都能使用 synchronized 来完成。synchronized 的『万能』也间接造就了它被程序员滥用的局面，**越『万能』的并发控制，通常会伴随着越大的性能影响**。

#### Java 中重排序 happens-before 规则

Happens-before 的前后两个操作不会被重排序且后者对前者的内存可见。

-  **程序次序法则**：线程中的每个动作 A 都 happens-before 于该线程中的每一个动作 B，其中，在程序中，所有的动作 B 都能出现在 A 之后。
-  **监视器锁法则**：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。
-  **volatile变量法则**：对 volatile 域的写入操作 happens-before 于每一个后续对同一个域的读写操作。
-  **线程启动法则**：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。
-  **线程终结法则**：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或 Thread.isAlive 返回 false。
-  **中断法则**：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。
-  **终结法则**：一个对象的构造函数的结束 happens-before 于这个对象finalizer的开始。
-  **传递性**：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before 于 C

这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

##### 实例（『时间上的先后顺序』与『happens-before』之间的不同）

```java
    private int value;

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }
```

一个普通的 bean 操作，存在线程 A 和 B，线程 A 先（时间上的先后）调用了`setValue(1)`，然后线程 B 调用了同一个对象的`getValue()`，那么线程B收到的返回值是什么？

这里分析一下 happens-before 的各种规则。

1. 由于两个方法分别由线程 A 和线程 B 调用，不在一个线程中，所以程序次序规则在这里不适用；
2. 由于没有同步块，自然就不会发生 lock 和 unlock 操作，所以管程锁定规则不适用；
3. 由于 value 变量没有被 volatile 关键字修饰，所以 volatile 变量规则不适用；
4. 后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系；
5. 因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起。

因此我们可以判定尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中`getValue()`方法的返回结果，换句话说，这里面的操作不是线程安全的。

通过上面的例子，我们可以得出结论：一个操作“时间上的先发生”不代表这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是『时间上的先发生』呢？**很遗憾，这个推论也是不成立的**，一个典型的例子就是多次提到的“指令重排序”。看下面这个简单代码块

```java
// 以下操作在同一个线程中执行
int i = 1;
int j = 2;
```

根据程序次序规则，`int i=1` 的操作先行发生于 `int j=2`，但是 `intj=2` 的代码完全可能先被处理器执行，这并不影响 happens-before 原则的正确性，因为我们在这条线程之中没有办法感知到这点。

时间先后顺序与 happens-before 原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以 happens-before 原则为准。

## Java 与线程

### 线程的实现

我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。

主流的操作系统都提供了线程实现，Java 语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行 start() 且还未结束的 java.lang.Thread 类的实例就代表了一个线程。我们注意到 Thread 类与大部分的Java API有显著的差别，它的所有关键方法都是声明为 Native 的。在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段）。

实现线程主要有3种方式：**使用内核线程实现**、使用**用户线程实现**和使用**用户线程加轻量级进程混合实现**。

#### 使用内核线程实现

内核线程（Kernel-Level Thread, KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，**这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上**。**每个内核线程可以视为内核的一个分身**，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。

程序一般不会直接去使用内核线程，而是去**使用内核线程的一种高级接口——轻量级进程**（Light Weight Process, LWP），轻量级进程就是我们通常意义上所讲的线程，由于**每个轻量级进程都由一个内核线程支持**，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间 1:1 的关系称为一对一的线程模型。

![轻量级进程与内核线程之间 1:1 的关系](https://github.com/BingLau7/blog/blob/master/images/blog_39/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.png?raw=true)

由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。

但是轻量级进程具有它的局限性：

-  首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。
-  其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

#### 使用用户线程实现

狭义上的用户线程指的是**完全建立在用户空间的线程库上**，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。**如果程序实现得当，这种线程不需要切换到内核态**，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间 1:N 的关系称为一对多的线程模型。

![进程与用户线程之间的关系](https://github.com/BingLau7/blog/blob/master/images/blog_39/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.png?raw=true)

使用用户线程的**优势在于不需要系统内核支援**，**劣势也在于没有系统内核的支援**，所有的线程操作都需要用户程序自己处理。

#### 使用用户线程加轻量级进程混合实现

线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，**既存在用户线程，也存在轻量级进程**。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而**操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险**。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系

![用户线程与轻量级进程之间的关系](https://github.com/BingLau7/blog/blob/master/images/blog_39/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png?raw=true)

#### Java 线程的实现

在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了 Java 虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定 Java 线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对 Java 程序的编码和运行过程来说，这些差异都是透明的。

Java SE 最常用的 JVM 是 Oracle/Sun 研发的 HotSpot VM。在这个 JVM 的较新版本所支持的所有平台上，它都是使用 1:1 线程模型的——除了Solaris之外，它是个特例。

这是HotSpot VM在Solaris上所支持的线程模型：[Java(TM) and Solaris(TM) Threading](http://www.oracle.com/technetwork/java/threads-140302.html)

### Java 线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Schedul-ing）。**Java使用的线程调度方式就是抢占式调度。**

#### 协同式线程调度

线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。

协同式多线程的**最大好处是实现简单**，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。它的**坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里**。

#### 抢占式线程调度

每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题。

### 状态转换

Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下。

-  New：创建后尚未启动的线程处于这种状态。   
-  Runable：Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是**处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间**。   
-  Waiting：**处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。**以下方法会让线程陷入无限期的等待状态：   
   -  没有设置Timeout参数的Object.wait()方法。
   -  没有设置Timeout参数的Thread.join()方法。
   -  LockSup-port.park()方法。   
-  Timed Waiting：**处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒**。以下方法会让线程进入限期等待状态：
   -  Thread.sleep()方法。   
   -  设置了Timeout参数的Object.wait()方法。   
   -  设置了Timeout参数的Thread.join()方法。   
   -  LockSupport.parkNanos()方法。
   -  LockSupport.parkUntil()方法。
-  Blocked：线程被阻塞了，**『阻塞状态』与『等待状态』的区别是：『阻塞状态』在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而『等待状态』则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。**   
-  Terminated：已终止线程的线程状态，线程已经结束执行。

![线程状态转换关系](https://github.com/BingLau7/blog/blob/master/images/blog_39/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E5%9B%BE.png?raw=true)

## 参考文档

《深入理解 Java 虚拟机》

《深入理解计算机系统》

[Java内存访问重排序的研究](https://tech.meituan.com/java-memory-reordering.html)
